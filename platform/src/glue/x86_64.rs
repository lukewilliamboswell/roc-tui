// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]


#[derive(Clone, Copy, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct Bounds {
    pub height: u16,
    pub width: u16,
}



#[repr(C)]
#[derive(Debug, Clone)]
pub struct RocFunction_66 {
    closure_data: roc_std::RocList<u8>,
}

impl RocFunction_66 {
    pub fn force_thunk(mut self, arg0: Bounds) -> () {
        extern "C" {
            fn roc__mainForHost_0_caller(arg0: *const Bounds,  closure_data: *mut u8, output: *mut ());
        }

        let mut output = std::mem::MaybeUninit::uninit();
        let ptr = &mut self.closure_data as *mut _ as *mut u8;

        unsafe { roc__mainForHost_0_caller(&arg0,  ptr, output.as_mut_ptr(), ) };

        // ownership of the closure is transferred back to roc
        core::mem::forget(self.closure_data);

        unsafe { output.assume_init() }
    }
}#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum TextModifier {
    Bold = 0,
    CrossedOut = 1,
    Dim = 2,
    Hidden = 3,
    Italic = 4,
    RapidBlink = 5,
    Reversed = 6,
    SlowBlink = 7,
    Underlined = 8,
}

impl core::fmt::Debug for TextModifier {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Bold => f.write_str("TextModifier::Bold"),
            Self::CrossedOut => f.write_str("TextModifier::CrossedOut"),
            Self::Dim => f.write_str("TextModifier::Dim"),
            Self::Hidden => f.write_str("TextModifier::Hidden"),
            Self::Italic => f.write_str("TextModifier::Italic"),
            Self::RapidBlink => f.write_str("TextModifier::RapidBlink"),
            Self::Reversed => f.write_str("TextModifier::Reversed"),
            Self::SlowBlink => f.write_str("TextModifier::SlowBlink"),
            Self::Underlined => f.write_str("TextModifier::Underlined"),
        }
    }
}

#[derive(Clone, Copy, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
struct Color_Rgb {
    pub f0: u8,
    pub f1: u8,
    pub f2: u8,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_Color {
    Black = 0,
    Blue = 1,
    Cyan = 2,
    DarkGray = 3,
    Default = 4,
    Gray = 5,
    Green = 6,
    Indexed = 7,
    LightBlue = 8,
    LightCyan = 9,
    LightGreen = 10,
    LightMagenta = 11,
    LightRed = 12,
    LightYellow = 13,
    Magenta = 14,
    Red = 15,
    Rgb = 16,
    White = 17,
    Yellow = 18,
}

impl core::fmt::Debug for discriminant_Color {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Black => f.write_str("discriminant_Color::Black"),
            Self::Blue => f.write_str("discriminant_Color::Blue"),
            Self::Cyan => f.write_str("discriminant_Color::Cyan"),
            Self::DarkGray => f.write_str("discriminant_Color::DarkGray"),
            Self::Default => f.write_str("discriminant_Color::Default"),
            Self::Gray => f.write_str("discriminant_Color::Gray"),
            Self::Green => f.write_str("discriminant_Color::Green"),
            Self::Indexed => f.write_str("discriminant_Color::Indexed"),
            Self::LightBlue => f.write_str("discriminant_Color::LightBlue"),
            Self::LightCyan => f.write_str("discriminant_Color::LightCyan"),
            Self::LightGreen => f.write_str("discriminant_Color::LightGreen"),
            Self::LightMagenta => f.write_str("discriminant_Color::LightMagenta"),
            Self::LightRed => f.write_str("discriminant_Color::LightRed"),
            Self::LightYellow => f.write_str("discriminant_Color::LightYellow"),
            Self::Magenta => f.write_str("discriminant_Color::Magenta"),
            Self::Red => f.write_str("discriminant_Color::Red"),
            Self::Rgb => f.write_str("discriminant_Color::Rgb"),
            Self::White => f.write_str("discriminant_Color::White"),
            Self::Yellow => f.write_str("discriminant_Color::Yellow"),
        }
    }
}

#[repr(C, align(1))]
pub union union_Color {
    Black: (),
    Blue: (),
    Cyan: (),
    DarkGray: (),
    Default: (),
    Gray: (),
    Green: (),
    Indexed: u8,
    LightBlue: (),
    LightCyan: (),
    LightGreen: (),
    LightMagenta: (),
    LightRed: (),
    LightYellow: (),
    Magenta: (),
    Red: (),
    Rgb: Color_Rgb,
    White: (),
    Yellow: (),
}

const _SIZE_CHECK_union_Color: () = assert!(core::mem::size_of::<union_Color>() == 4);
const _ALIGN_CHECK_union_Color: () = assert!(core::mem::align_of::<union_Color>() == 1);

const _SIZE_CHECK_Color: () = assert!(core::mem::size_of::<Color>() == 4);
const _ALIGN_CHECK_Color: () = assert!(core::mem::align_of::<Color>() == 1);

impl Color {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Color {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Color>(*bytes.as_ptr().add(3))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Color) {
        let discriminant_ptr: *mut discriminant_Color = (self as *mut Color).cast();

        unsafe {
            *(discriminant_ptr.add(3)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct Color {
    payload: union_Color,
    discriminant: discriminant_Color,
}

impl Clone for Color {
    fn clone(&self) -> Self {
        use discriminant_Color::*;

        let payload = unsafe {
            match self.discriminant {
                Black => union_Color {
                    Black: self.payload.Black.clone(),
                },
                Blue => union_Color {
                    Blue: self.payload.Blue.clone(),
                },
                Cyan => union_Color {
                    Cyan: self.payload.Cyan.clone(),
                },
                DarkGray => union_Color {
                    DarkGray: self.payload.DarkGray.clone(),
                },
                Default => union_Color {
                    Default: self.payload.Default.clone(),
                },
                Gray => union_Color {
                    Gray: self.payload.Gray.clone(),
                },
                Green => union_Color {
                    Green: self.payload.Green.clone(),
                },
                Indexed => union_Color {
                    Indexed: self.payload.Indexed.clone(),
                },
                LightBlue => union_Color {
                    LightBlue: self.payload.LightBlue.clone(),
                },
                LightCyan => union_Color {
                    LightCyan: self.payload.LightCyan.clone(),
                },
                LightGreen => union_Color {
                    LightGreen: self.payload.LightGreen.clone(),
                },
                LightMagenta => union_Color {
                    LightMagenta: self.payload.LightMagenta.clone(),
                },
                LightRed => union_Color {
                    LightRed: self.payload.LightRed.clone(),
                },
                LightYellow => union_Color {
                    LightYellow: self.payload.LightYellow.clone(),
                },
                Magenta => union_Color {
                    Magenta: self.payload.Magenta.clone(),
                },
                Red => union_Color {
                    Red: self.payload.Red.clone(),
                },
                Rgb => union_Color {
                    Rgb: self.payload.Rgb.clone(),
                },
                White => union_Color {
                    White: self.payload.White.clone(),
                },
                Yellow => union_Color {
                    Yellow: self.payload.Yellow.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for Color {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Color::*;

        unsafe {
            match self.discriminant {
                Black => {
                    let field: &() = &self.payload.Black;
                    f.debug_tuple("Color::Black").field(field).finish()
                },
                Blue => {
                    let field: &() = &self.payload.Blue;
                    f.debug_tuple("Color::Blue").field(field).finish()
                },
                Cyan => {
                    let field: &() = &self.payload.Cyan;
                    f.debug_tuple("Color::Cyan").field(field).finish()
                },
                DarkGray => {
                    let field: &() = &self.payload.DarkGray;
                    f.debug_tuple("Color::DarkGray").field(field).finish()
                },
                Default => {
                    let field: &() = &self.payload.Default;
                    f.debug_tuple("Color::Default").field(field).finish()
                },
                Gray => {
                    let field: &() = &self.payload.Gray;
                    f.debug_tuple("Color::Gray").field(field).finish()
                },
                Green => {
                    let field: &() = &self.payload.Green;
                    f.debug_tuple("Color::Green").field(field).finish()
                },
                Indexed => {
                    let field: &u8 = &self.payload.Indexed;
                    f.debug_tuple("Color::Indexed").field(field).finish()
                },
                LightBlue => {
                    let field: &() = &self.payload.LightBlue;
                    f.debug_tuple("Color::LightBlue").field(field).finish()
                },
                LightCyan => {
                    let field: &() = &self.payload.LightCyan;
                    f.debug_tuple("Color::LightCyan").field(field).finish()
                },
                LightGreen => {
                    let field: &() = &self.payload.LightGreen;
                    f.debug_tuple("Color::LightGreen").field(field).finish()
                },
                LightMagenta => {
                    let field: &() = &self.payload.LightMagenta;
                    f.debug_tuple("Color::LightMagenta").field(field).finish()
                },
                LightRed => {
                    let field: &() = &self.payload.LightRed;
                    f.debug_tuple("Color::LightRed").field(field).finish()
                },
                LightYellow => {
                    let field: &() = &self.payload.LightYellow;
                    f.debug_tuple("Color::LightYellow").field(field).finish()
                },
                Magenta => {
                    let field: &() = &self.payload.Magenta;
                    f.debug_tuple("Color::Magenta").field(field).finish()
                },
                Red => {
                    let field: &() = &self.payload.Red;
                    f.debug_tuple("Color::Red").field(field).finish()
                },
                Rgb => {
                    let field: &Color_Rgb = &self.payload.Rgb;
                    f.debug_tuple("Color::Rgb").field(field).finish()
                },
                White => {
                    let field: &() = &self.payload.White;
                    f.debug_tuple("Color::White").field(field).finish()
                },
                Yellow => {
                    let field: &() = &self.payload.Yellow;
                    f.debug_tuple("Color::Yellow").field(field).finish()
                },
            }
        }
    }
}

impl Eq for Color {}

impl PartialEq for Color {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_Color::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Black => self.payload.Black == other.payload.Black,
                Blue => self.payload.Blue == other.payload.Blue,
                Cyan => self.payload.Cyan == other.payload.Cyan,
                DarkGray => self.payload.DarkGray == other.payload.DarkGray,
                Default => self.payload.Default == other.payload.Default,
                Gray => self.payload.Gray == other.payload.Gray,
                Green => self.payload.Green == other.payload.Green,
                Indexed => self.payload.Indexed == other.payload.Indexed,
                LightBlue => self.payload.LightBlue == other.payload.LightBlue,
                LightCyan => self.payload.LightCyan == other.payload.LightCyan,
                LightGreen => self.payload.LightGreen == other.payload.LightGreen,
                LightMagenta => self.payload.LightMagenta == other.payload.LightMagenta,
                LightRed => self.payload.LightRed == other.payload.LightRed,
                LightYellow => self.payload.LightYellow == other.payload.LightYellow,
                Magenta => self.payload.Magenta == other.payload.Magenta,
                Red => self.payload.Red == other.payload.Red,
                Rgb => self.payload.Rgb == other.payload.Rgb,
                White => self.payload.White == other.payload.White,
                Yellow => self.payload.Yellow == other.payload.Yellow,
            }
        }
    }
}

impl Ord for Color {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for Color {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_Color::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Black => self.payload.Black.partial_cmp(&other.payload.Black),
                    Blue => self.payload.Blue.partial_cmp(&other.payload.Blue),
                    Cyan => self.payload.Cyan.partial_cmp(&other.payload.Cyan),
                    DarkGray => self.payload.DarkGray.partial_cmp(&other.payload.DarkGray),
                    Default => self.payload.Default.partial_cmp(&other.payload.Default),
                    Gray => self.payload.Gray.partial_cmp(&other.payload.Gray),
                    Green => self.payload.Green.partial_cmp(&other.payload.Green),
                    Indexed => self.payload.Indexed.partial_cmp(&other.payload.Indexed),
                    LightBlue => self.payload.LightBlue.partial_cmp(&other.payload.LightBlue),
                    LightCyan => self.payload.LightCyan.partial_cmp(&other.payload.LightCyan),
                    LightGreen => self.payload.LightGreen.partial_cmp(&other.payload.LightGreen),
                    LightMagenta => self.payload.LightMagenta.partial_cmp(&other.payload.LightMagenta),
                    LightRed => self.payload.LightRed.partial_cmp(&other.payload.LightRed),
                    LightYellow => self.payload.LightYellow.partial_cmp(&other.payload.LightYellow),
                    Magenta => self.payload.Magenta.partial_cmp(&other.payload.Magenta),
                    Red => self.payload.Red.partial_cmp(&other.payload.Red),
                    Rgb => self.payload.Rgb.partial_cmp(&other.payload.Rgb),
                    White => self.payload.White.partial_cmp(&other.payload.White),
                    Yellow => self.payload.Yellow.partial_cmp(&other.payload.Yellow),
                }
            },
        }
    }
}

impl core::hash::Hash for Color {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_Color::*;

        unsafe {
            match self.discriminant {
                Black => self.payload.Black.hash(state),
                Blue => self.payload.Blue.hash(state),
                Cyan => self.payload.Cyan.hash(state),
                DarkGray => self.payload.DarkGray.hash(state),
                Default => self.payload.Default.hash(state),
                Gray => self.payload.Gray.hash(state),
                Green => self.payload.Green.hash(state),
                Indexed => self.payload.Indexed.hash(state),
                LightBlue => self.payload.LightBlue.hash(state),
                LightCyan => self.payload.LightCyan.hash(state),
                LightGreen => self.payload.LightGreen.hash(state),
                LightMagenta => self.payload.LightMagenta.hash(state),
                LightRed => self.payload.LightRed.hash(state),
                LightYellow => self.payload.LightYellow.hash(state),
                Magenta => self.payload.Magenta.hash(state),
                Red => self.payload.Red.hash(state),
                Rgb => self.payload.Rgb.hash(state),
                White => self.payload.White.hash(state),
                Yellow => self.payload.Yellow.hash(state),
            }
        }
    }
}

impl Color {

    pub fn is_Black(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::Black)
    }

    pub fn is_Blue(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::Blue)
    }

    pub fn is_Cyan(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::Cyan)
    }

    pub fn is_DarkGray(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::DarkGray)
    }

    pub fn is_Default(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::Default)
    }

    pub fn is_Gray(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::Gray)
    }

    pub fn is_Green(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::Green)
    }

    pub fn unwrap_Indexed(mut self) -> u8 {
        debug_assert_eq!(self.discriminant, discriminant_Color::Indexed);
        unsafe { self.payload.Indexed }
    }

    pub fn is_Indexed(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::Indexed)
    }

    pub fn is_LightBlue(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::LightBlue)
    }

    pub fn is_LightCyan(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::LightCyan)
    }

    pub fn is_LightGreen(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::LightGreen)
    }

    pub fn is_LightMagenta(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::LightMagenta)
    }

    pub fn is_LightRed(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::LightRed)
    }

    pub fn is_LightYellow(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::LightYellow)
    }

    pub fn is_Magenta(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::Magenta)
    }

    pub fn is_Red(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::Red)
    }

    pub fn unwrap_Rgb(mut self) -> Color_Rgb {
        debug_assert_eq!(self.discriminant, discriminant_Color::Rgb);
        unsafe { self.payload.Rgb }
    }

    pub fn is_Rgb(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::Rgb)
    }

    pub fn is_White(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::White)
    }

    pub fn is_Yellow(&self) -> bool {
        matches!(self.discriminant, discriminant_Color::Yellow)
    }
}



impl Color {

    pub fn Black() -> Self {
        Self {
            discriminant: discriminant_Color::Black,
            payload: union_Color {
                Black: (),
            }
        }
    }

    pub fn Blue() -> Self {
        Self {
            discriminant: discriminant_Color::Blue,
            payload: union_Color {
                Blue: (),
            }
        }
    }

    pub fn Cyan() -> Self {
        Self {
            discriminant: discriminant_Color::Cyan,
            payload: union_Color {
                Cyan: (),
            }
        }
    }

    pub fn DarkGray() -> Self {
        Self {
            discriminant: discriminant_Color::DarkGray,
            payload: union_Color {
                DarkGray: (),
            }
        }
    }

    pub fn Default() -> Self {
        Self {
            discriminant: discriminant_Color::Default,
            payload: union_Color {
                Default: (),
            }
        }
    }

    pub fn Gray() -> Self {
        Self {
            discriminant: discriminant_Color::Gray,
            payload: union_Color {
                Gray: (),
            }
        }
    }

    pub fn Green() -> Self {
        Self {
            discriminant: discriminant_Color::Green,
            payload: union_Color {
                Green: (),
            }
        }
    }

    pub fn Indexed(payload: u8) -> Self {
        Self {
            discriminant: discriminant_Color::Indexed,
            payload: union_Color {
                Indexed: payload,
            }
        }
    }

    pub fn LightBlue() -> Self {
        Self {
            discriminant: discriminant_Color::LightBlue,
            payload: union_Color {
                LightBlue: (),
            }
        }
    }

    pub fn LightCyan() -> Self {
        Self {
            discriminant: discriminant_Color::LightCyan,
            payload: union_Color {
                LightCyan: (),
            }
        }
    }

    pub fn LightGreen() -> Self {
        Self {
            discriminant: discriminant_Color::LightGreen,
            payload: union_Color {
                LightGreen: (),
            }
        }
    }

    pub fn LightMagenta() -> Self {
        Self {
            discriminant: discriminant_Color::LightMagenta,
            payload: union_Color {
                LightMagenta: (),
            }
        }
    }

    pub fn LightRed() -> Self {
        Self {
            discriminant: discriminant_Color::LightRed,
            payload: union_Color {
                LightRed: (),
            }
        }
    }

    pub fn LightYellow() -> Self {
        Self {
            discriminant: discriminant_Color::LightYellow,
            payload: union_Color {
                LightYellow: (),
            }
        }
    }

    pub fn Magenta() -> Self {
        Self {
            discriminant: discriminant_Color::Magenta,
            payload: union_Color {
                Magenta: (),
            }
        }
    }

    pub fn Red() -> Self {
        Self {
            discriminant: discriminant_Color::Red,
            payload: union_Color {
                Red: (),
            }
        }
    }

    pub fn Rgb(payload: Color_Rgb) -> Self {
        Self {
            discriminant: discriminant_Color::Rgb,
            payload: union_Color {
                Rgb: payload,
            }
        }
    }

    pub fn White() -> Self {
        Self {
            discriminant: discriminant_Color::White,
            payload: union_Color {
                White: (),
            }
        }
    }

    pub fn Yellow() -> Self {
        Self {
            discriminant: discriminant_Color::Yellow,
            payload: union_Color {
                Yellow: (),
            }
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct Style {
    pub modifiers: roc_std::RocList<TextModifier>,
    pub bg: Color,
    pub fg: Color,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum BorderModifier {
    All = 0,
    Bottom = 1,
    Left = 2,
    None = 3,
    Right = 4,
    Top = 5,
}

impl core::fmt::Debug for BorderModifier {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::All => f.write_str("BorderModifier::All"),
            Self::Bottom => f.write_str("BorderModifier::Bottom"),
            Self::Left => f.write_str("BorderModifier::Left"),
            Self::None => f.write_str("BorderModifier::None"),
            Self::Right => f.write_str("BorderModifier::Right"),
            Self::Top => f.write_str("BorderModifier::Top"),
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct Span {
    pub style: Style,
    pub text: roc_std::RocStr,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum BorderType {
    Double = 0,
    Plain = 1,
    Rounded = 2,
    Thick = 3,
}

impl core::fmt::Debug for BorderType {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Double => f.write_str("BorderType::Double"),
            Self::Plain => f.write_str("BorderType::Plain"),
            Self::Rounded => f.write_str("BorderType::Rounded"),
            Self::Thick => f.write_str("BorderType::Thick"),
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum Alignment {
    Center = 0,
    Left = 1,
    Right = 2,
}

impl core::fmt::Debug for Alignment {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Center => f.write_str("Alignment::Center"),
            Self::Left => f.write_str("Alignment::Left"),
            Self::Right => f.write_str("Alignment::Right"),
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct BlockConfig {
    pub borderStyle: Style,
    pub borders: roc_std::RocList<BorderModifier>,
    pub style: Style,
    pub title: Span,
    pub borderType: BorderType,
    pub titleAlignment: Alignment,
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(transparent)]
struct Elem_Block {
    pub f0: BlockConfig,
}

#[derive(Clone, Copy, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
struct Constraint_Ratio {
    pub f0: u32,
    pub f1: u32,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_Constraint {
    Length = 0,
    Max = 1,
    Min = 2,
    Percentage = 3,
    Ratio = 4,
}

impl core::fmt::Debug for discriminant_Constraint {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Length => f.write_str("discriminant_Constraint::Length"),
            Self::Max => f.write_str("discriminant_Constraint::Max"),
            Self::Min => f.write_str("discriminant_Constraint::Min"),
            Self::Percentage => f.write_str("discriminant_Constraint::Percentage"),
            Self::Ratio => f.write_str("discriminant_Constraint::Ratio"),
        }
    }
}

#[repr(C, align(4))]
pub union union_Constraint {
    Length: u16,
    Max: u16,
    Min: u16,
    Percentage: u16,
    Ratio: Constraint_Ratio,
}

const _SIZE_CHECK_union_Constraint: () = assert!(core::mem::size_of::<union_Constraint>() == 12);
const _ALIGN_CHECK_union_Constraint: () = assert!(core::mem::align_of::<union_Constraint>() == 4);

const _SIZE_CHECK_Constraint: () = assert!(core::mem::size_of::<Constraint>() == 12);
const _ALIGN_CHECK_Constraint: () = assert!(core::mem::align_of::<Constraint>() == 4);

impl Constraint {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Constraint {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Constraint>(*bytes.as_ptr().add(8))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Constraint) {
        let discriminant_ptr: *mut discriminant_Constraint = (self as *mut Constraint).cast();

        unsafe {
            *(discriminant_ptr.add(8)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct Constraint {
    payload: union_Constraint,
    discriminant: discriminant_Constraint,
}

impl Clone for Constraint {
    fn clone(&self) -> Self {
        use discriminant_Constraint::*;

        let payload = unsafe {
            match self.discriminant {
                Length => union_Constraint {
                    Length: self.payload.Length.clone(),
                },
                Max => union_Constraint {
                    Max: self.payload.Max.clone(),
                },
                Min => union_Constraint {
                    Min: self.payload.Min.clone(),
                },
                Percentage => union_Constraint {
                    Percentage: self.payload.Percentage.clone(),
                },
                Ratio => union_Constraint {
                    Ratio: self.payload.Ratio.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for Constraint {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Constraint::*;

        unsafe {
            match self.discriminant {
                Length => {
                    let field: &u16 = &self.payload.Length;
                    f.debug_tuple("Constraint::Length").field(field).finish()
                },
                Max => {
                    let field: &u16 = &self.payload.Max;
                    f.debug_tuple("Constraint::Max").field(field).finish()
                },
                Min => {
                    let field: &u16 = &self.payload.Min;
                    f.debug_tuple("Constraint::Min").field(field).finish()
                },
                Percentage => {
                    let field: &u16 = &self.payload.Percentage;
                    f.debug_tuple("Constraint::Percentage").field(field).finish()
                },
                Ratio => {
                    let field: &Constraint_Ratio = &self.payload.Ratio;
                    f.debug_tuple("Constraint::Ratio").field(field).finish()
                },
            }
        }
    }
}

impl Eq for Constraint {}

impl PartialEq for Constraint {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_Constraint::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Length => self.payload.Length == other.payload.Length,
                Max => self.payload.Max == other.payload.Max,
                Min => self.payload.Min == other.payload.Min,
                Percentage => self.payload.Percentage == other.payload.Percentage,
                Ratio => self.payload.Ratio == other.payload.Ratio,
            }
        }
    }
}

impl Ord for Constraint {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for Constraint {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_Constraint::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Length => self.payload.Length.partial_cmp(&other.payload.Length),
                    Max => self.payload.Max.partial_cmp(&other.payload.Max),
                    Min => self.payload.Min.partial_cmp(&other.payload.Min),
                    Percentage => self.payload.Percentage.partial_cmp(&other.payload.Percentage),
                    Ratio => self.payload.Ratio.partial_cmp(&other.payload.Ratio),
                }
            },
        }
    }
}

impl core::hash::Hash for Constraint {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_Constraint::*;

        unsafe {
            match self.discriminant {
                Length => self.payload.Length.hash(state),
                Max => self.payload.Max.hash(state),
                Min => self.payload.Min.hash(state),
                Percentage => self.payload.Percentage.hash(state),
                Ratio => self.payload.Ratio.hash(state),
            }
        }
    }
}

impl Constraint {

    pub fn unwrap_Length(mut self) -> u16 {
        debug_assert_eq!(self.discriminant, discriminant_Constraint::Length);
        unsafe { self.payload.Length }
    }

    pub fn is_Length(&self) -> bool {
        matches!(self.discriminant, discriminant_Constraint::Length)
    }

    pub fn unwrap_Max(mut self) -> u16 {
        debug_assert_eq!(self.discriminant, discriminant_Constraint::Max);
        unsafe { self.payload.Max }
    }

    pub fn is_Max(&self) -> bool {
        matches!(self.discriminant, discriminant_Constraint::Max)
    }

    pub fn unwrap_Min(mut self) -> u16 {
        debug_assert_eq!(self.discriminant, discriminant_Constraint::Min);
        unsafe { self.payload.Min }
    }

    pub fn is_Min(&self) -> bool {
        matches!(self.discriminant, discriminant_Constraint::Min)
    }

    pub fn unwrap_Percentage(mut self) -> u16 {
        debug_assert_eq!(self.discriminant, discriminant_Constraint::Percentage);
        unsafe { self.payload.Percentage }
    }

    pub fn is_Percentage(&self) -> bool {
        matches!(self.discriminant, discriminant_Constraint::Percentage)
    }

    pub fn unwrap_Ratio(mut self) -> Constraint_Ratio {
        debug_assert_eq!(self.discriminant, discriminant_Constraint::Ratio);
        unsafe { self.payload.Ratio }
    }

    pub fn is_Ratio(&self) -> bool {
        matches!(self.discriminant, discriminant_Constraint::Ratio)
    }
}



impl Constraint {

    pub fn Length(payload: u16) -> Self {
        Self {
            discriminant: discriminant_Constraint::Length,
            payload: union_Constraint {
                Length: payload,
            }
        }
    }

    pub fn Max(payload: u16) -> Self {
        Self {
            discriminant: discriminant_Constraint::Max,
            payload: union_Constraint {
                Max: payload,
            }
        }
    }

    pub fn Min(payload: u16) -> Self {
        Self {
            discriminant: discriminant_Constraint::Min,
            payload: union_Constraint {
                Min: payload,
            }
        }
    }

    pub fn Percentage(payload: u16) -> Self {
        Self {
            discriminant: discriminant_Constraint::Percentage,
            payload: union_Constraint {
                Percentage: payload,
            }
        }
    }

    pub fn Ratio(payload: Constraint_Ratio) -> Self {
        Self {
            discriminant: discriminant_Constraint::Ratio,
            payload: union_Constraint {
                Ratio: payload,
            }
        }
    }
}

#[derive(Clone, Copy, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct ModalPosition {
    pub percentX: u16,
    pub percentY: u16,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_PopupConfig {
    Centered = 0,
    None = 1,
}

impl core::fmt::Debug for discriminant_PopupConfig {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Centered => f.write_str("discriminant_PopupConfig::Centered"),
            Self::None => f.write_str("discriminant_PopupConfig::None"),
        }
    }
}

#[repr(C, align(2))]
pub union union_PopupConfig {
    Centered: ModalPosition,
    None: (),
}

const _SIZE_CHECK_union_PopupConfig: () = assert!(core::mem::size_of::<union_PopupConfig>() == 4);
const _ALIGN_CHECK_union_PopupConfig: () = assert!(core::mem::align_of::<union_PopupConfig>() == 2);

const _SIZE_CHECK_PopupConfig: () = assert!(core::mem::size_of::<PopupConfig>() == 6);
const _ALIGN_CHECK_PopupConfig: () = assert!(core::mem::align_of::<PopupConfig>() == 2);

impl PopupConfig {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_PopupConfig {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_PopupConfig>(*bytes.as_ptr().add(4))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_PopupConfig) {
        let discriminant_ptr: *mut discriminant_PopupConfig = (self as *mut PopupConfig).cast();

        unsafe {
            *(discriminant_ptr.add(4)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct PopupConfig {
    payload: union_PopupConfig,
    discriminant: discriminant_PopupConfig,
}

impl Clone for PopupConfig {
    fn clone(&self) -> Self {
        use discriminant_PopupConfig::*;

        let payload = unsafe {
            match self.discriminant {
                Centered => union_PopupConfig {
                    Centered: self.payload.Centered.clone(),
                },
                None => union_PopupConfig {
                    None: self.payload.None.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for PopupConfig {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_PopupConfig::*;

        unsafe {
            match self.discriminant {
                Centered => {
                    let field: &ModalPosition = &self.payload.Centered;
                    f.debug_tuple("PopupConfig::Centered").field(field).finish()
                },
                None => {
                    let field: &() = &self.payload.None;
                    f.debug_tuple("PopupConfig::None").field(field).finish()
                },
            }
        }
    }
}

impl Eq for PopupConfig {}

impl PartialEq for PopupConfig {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_PopupConfig::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Centered => self.payload.Centered == other.payload.Centered,
                None => self.payload.None == other.payload.None,
            }
        }
    }
}

impl Ord for PopupConfig {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for PopupConfig {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_PopupConfig::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Centered => self.payload.Centered.partial_cmp(&other.payload.Centered),
                    None => self.payload.None.partial_cmp(&other.payload.None),
                }
            },
        }
    }
}

impl core::hash::Hash for PopupConfig {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_PopupConfig::*;

        unsafe {
            match self.discriminant {
                Centered => self.payload.Centered.hash(state),
                None => self.payload.None.hash(state),
            }
        }
    }
}

impl PopupConfig {

    pub fn unwrap_Centered(mut self) -> ModalPosition {
        debug_assert_eq!(self.discriminant, discriminant_PopupConfig::Centered);
        unsafe { self.payload.Centered }
    }

    pub fn is_Centered(&self) -> bool {
        matches!(self.discriminant, discriminant_PopupConfig::Centered)
    }

    pub fn is_None(&self) -> bool {
        matches!(self.discriminant, discriminant_PopupConfig::None)
    }
}



impl PopupConfig {

    pub fn Centered(payload: ModalPosition) -> Self {
        Self {
            discriminant: discriminant_PopupConfig::Centered,
            payload: union_PopupConfig {
                Centered: payload,
            }
        }
    }

    pub fn None() -> Self {
        Self {
            discriminant: discriminant_PopupConfig::None,
            payload: union_PopupConfig {
                None: (),
            }
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum LayoutDirection {
    Horizontal = 0,
    Vertical = 1,
}

impl core::fmt::Debug for LayoutDirection {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Horizontal => f.write_str("LayoutDirection::Horizontal"),
            Self::Vertical => f.write_str("LayoutDirection::Vertical"),
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct LayoutConfig {
    pub constraints: roc_std::RocList<Constraint>,
    pub hMargin: u16,
    pub popup: PopupConfig,
    pub vMargin: u16,
    pub direction: LayoutDirection,
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
struct Elem_Layout {
    pub f0: roc_std::RocList<Elem>,
    pub f1: LayoutConfig,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_ListSelection {
    None = 0,
    Selected = 1,
}

impl core::fmt::Debug for discriminant_ListSelection {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::None => f.write_str("discriminant_ListSelection::None"),
            Self::Selected => f.write_str("discriminant_ListSelection::Selected"),
        }
    }
}

#[repr(C, align(8))]
pub union union_ListSelection {
    None: (),
    Selected: u64,
}

const _SIZE_CHECK_union_ListSelection: () = assert!(core::mem::size_of::<union_ListSelection>() == 8);
const _ALIGN_CHECK_union_ListSelection: () = assert!(core::mem::align_of::<union_ListSelection>() == 8);

const _SIZE_CHECK_ListSelection: () = assert!(core::mem::size_of::<ListSelection>() == 16);
const _ALIGN_CHECK_ListSelection: () = assert!(core::mem::align_of::<ListSelection>() == 8);

impl ListSelection {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ListSelection {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ListSelection>(*bytes.as_ptr().add(8))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ListSelection) {
        let discriminant_ptr: *mut discriminant_ListSelection = (self as *mut ListSelection).cast();

        unsafe {
            *(discriminant_ptr.add(8)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct ListSelection {
    payload: union_ListSelection,
    discriminant: discriminant_ListSelection,
}

impl Clone for ListSelection {
    fn clone(&self) -> Self {
        use discriminant_ListSelection::*;

        let payload = unsafe {
            match self.discriminant {
                None => union_ListSelection {
                    None: self.payload.None.clone(),
                },
                Selected => union_ListSelection {
                    Selected: self.payload.Selected.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for ListSelection {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_ListSelection::*;

        unsafe {
            match self.discriminant {
                None => {
                    let field: &() = &self.payload.None;
                    f.debug_tuple("ListSelection::None").field(field).finish()
                },
                Selected => {
                    let field: &u64 = &self.payload.Selected;
                    f.debug_tuple("ListSelection::Selected").field(field).finish()
                },
            }
        }
    }
}

impl Eq for ListSelection {}

impl PartialEq for ListSelection {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_ListSelection::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                None => self.payload.None == other.payload.None,
                Selected => self.payload.Selected == other.payload.Selected,
            }
        }
    }
}

impl Ord for ListSelection {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for ListSelection {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_ListSelection::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    None => self.payload.None.partial_cmp(&other.payload.None),
                    Selected => self.payload.Selected.partial_cmp(&other.payload.Selected),
                }
            },
        }
    }
}

impl core::hash::Hash for ListSelection {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_ListSelection::*;

        unsafe {
            match self.discriminant {
                None => self.payload.None.hash(state),
                Selected => self.payload.Selected.hash(state),
            }
        }
    }
}

impl ListSelection {

    pub fn is_None(&self) -> bool {
        matches!(self.discriminant, discriminant_ListSelection::None)
    }

    pub fn unwrap_Selected(mut self) -> u64 {
        debug_assert_eq!(self.discriminant, discriminant_ListSelection::Selected);
        unsafe { self.payload.Selected }
    }

    pub fn is_Selected(&self) -> bool {
        matches!(self.discriminant, discriminant_ListSelection::Selected)
    }
}



impl ListSelection {

    pub fn None() -> Self {
        Self {
            discriminant: discriminant_ListSelection::None,
            payload: union_ListSelection {
                None: (),
            }
        }
    }

    pub fn Selected(payload: u64) -> Self {
        Self {
            discriminant: discriminant_ListSelection::Selected,
            payload: union_ListSelection {
                Selected: payload,
            }
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum Corner {
    BottomLeft = 0,
    BottomRight = 1,
    TopLeft = 2,
    TopRight = 3,
}

impl core::fmt::Debug for Corner {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::BottomLeft => f.write_str("Corner::BottomLeft"),
            Self::BottomRight => f.write_str("Corner::BottomRight"),
            Self::TopLeft => f.write_str("Corner::TopLeft"),
            Self::TopRight => f.write_str("Corner::TopRight"),
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct ListConfig {
    pub block: BlockConfig,
    pub highlightStyle: Style,
    pub highlightSymbol: roc_std::RocStr,
    pub items: roc_std::RocList<roc_std::RocList<Span>>,
    pub selected: ListSelection,
    pub style: Style,
    pub highlightSymbolRepeat: bool,
    pub startCorner: Corner,
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(transparent)]
struct Elem_ListItems {
    pub f0: ListConfig,
}

#[derive(Clone, Copy, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct CursorPosition {
    pub col: u16,
    pub row: u16,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_Cursor {
    At = 0,
    Hidden = 1,
}

impl core::fmt::Debug for discriminant_Cursor {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::At => f.write_str("discriminant_Cursor::At"),
            Self::Hidden => f.write_str("discriminant_Cursor::Hidden"),
        }
    }
}

#[repr(C, align(2))]
pub union union_Cursor {
    At: CursorPosition,
    Hidden: (),
}

const _SIZE_CHECK_union_Cursor: () = assert!(core::mem::size_of::<union_Cursor>() == 4);
const _ALIGN_CHECK_union_Cursor: () = assert!(core::mem::align_of::<union_Cursor>() == 2);

const _SIZE_CHECK_Cursor: () = assert!(core::mem::size_of::<Cursor>() == 6);
const _ALIGN_CHECK_Cursor: () = assert!(core::mem::align_of::<Cursor>() == 2);

impl Cursor {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Cursor {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Cursor>(*bytes.as_ptr().add(4))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Cursor) {
        let discriminant_ptr: *mut discriminant_Cursor = (self as *mut Cursor).cast();

        unsafe {
            *(discriminant_ptr.add(4)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct Cursor {
    payload: union_Cursor,
    discriminant: discriminant_Cursor,
}

impl Clone for Cursor {
    fn clone(&self) -> Self {
        use discriminant_Cursor::*;

        let payload = unsafe {
            match self.discriminant {
                At => union_Cursor {
                    At: self.payload.At.clone(),
                },
                Hidden => union_Cursor {
                    Hidden: self.payload.Hidden.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for Cursor {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Cursor::*;

        unsafe {
            match self.discriminant {
                At => {
                    let field: &CursorPosition = &self.payload.At;
                    f.debug_tuple("Cursor::At").field(field).finish()
                },
                Hidden => {
                    let field: &() = &self.payload.Hidden;
                    f.debug_tuple("Cursor::Hidden").field(field).finish()
                },
            }
        }
    }
}

impl Eq for Cursor {}

impl PartialEq for Cursor {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_Cursor::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                At => self.payload.At == other.payload.At,
                Hidden => self.payload.Hidden == other.payload.Hidden,
            }
        }
    }
}

impl Ord for Cursor {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for Cursor {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_Cursor::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    At => self.payload.At.partial_cmp(&other.payload.At),
                    Hidden => self.payload.Hidden.partial_cmp(&other.payload.Hidden),
                }
            },
        }
    }
}

impl core::hash::Hash for Cursor {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_Cursor::*;

        unsafe {
            match self.discriminant {
                At => self.payload.At.hash(state),
                Hidden => self.payload.Hidden.hash(state),
            }
        }
    }
}

impl Cursor {

    pub fn unwrap_At(mut self) -> CursorPosition {
        debug_assert_eq!(self.discriminant, discriminant_Cursor::At);
        unsafe { self.payload.At }
    }

    pub fn is_At(&self) -> bool {
        matches!(self.discriminant, discriminant_Cursor::At)
    }

    pub fn is_Hidden(&self) -> bool {
        matches!(self.discriminant, discriminant_Cursor::Hidden)
    }
}



impl Cursor {

    pub fn At(payload: CursorPosition) -> Self {
        Self {
            discriminant: discriminant_Cursor::At,
            payload: union_Cursor {
                At: payload,
            }
        }
    }

    pub fn Hidden() -> Self {
        Self {
            discriminant: discriminant_Cursor::Hidden,
            payload: union_Cursor {
                Hidden: (),
            }
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct ParagraphConfig {
    pub block: BlockConfig,
    pub text: roc_std::RocList<roc_std::RocList<Span>>,
    pub cursor: Cursor,
    pub scroll: u16,
    pub textAlignment: Alignment,
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(transparent)]
struct Elem_Paragraph {
    pub f0: ParagraphConfig,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_Elem {
    Block = 0,
    Layout = 1,
    ListItems = 2,
    Paragraph = 3,
}

impl core::fmt::Debug for discriminant_Elem {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Block => f.write_str("discriminant_Elem::Block"),
            Self::Layout => f.write_str("discriminant_Elem::Layout"),
            Self::ListItems => f.write_str("discriminant_Elem::ListItems"),
            Self::Paragraph => f.write_str("discriminant_Elem::Paragraph"),
        }
    }
}

#[repr(transparent)]
pub struct Elem(*mut union_Elem);

const _SIZE_CHECK_Elem: () = assert!(core::mem::size_of::<Elem>() == 8);
const _ALIGN_CHECK_Elem: () = assert!(core::mem::align_of::<Elem>() == 8);

impl Elem {
    pub fn discriminant(&self) -> discriminant_Elem {
        let discriminants = {
            use discriminant_Elem::*;

            [ Block, Layout, ListItems, Paragraph ]
        };

        if self.0.is_null() {
            unreachable!("this pointer cannot be NULL")
        } else  {
            match std::mem::size_of::<usize>() {
                4 => discriminants[self.0 as usize & 0b011],
                8 => discriminants[self.0 as usize & 0b111],
                _ => unreachable!(),
            }
        }
    }

    unsafe fn ptr_read_union(&self) -> core::mem::ManuallyDrop<union_Elem> {
        debug_assert!(!self.0.is_null());

        let mask = match std::mem::size_of::<usize>() {
            4 => !0b011usize,
            8 => !0b111usize,
            _ => unreachable!(),
        };

        let ptr = ((self.0 as usize) & mask) as *mut union_Elem;

        core::mem::ManuallyDrop::new(unsafe { std::ptr::read(ptr) })
    }

        pub fn is_Block(&self) -> bool {
        matches!(self.discriminant(), discriminant_Elem::Block)
    }

    pub fn Block(f0: BlockConfig) -> Self {
        let tag_id = discriminant_Elem::Block;

        let payload = Elem_Block { f0 } ;

        let union_payload = union_Elem { Block: core::mem::ManuallyDrop::new(payload) };

        let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(union_payload)) };

        Self((ptr as usize | tag_id as usize) as *mut _)
    }

    pub fn get_Block(mut self) -> Elem_Block {
        debug_assert!(self.is_Block());

        unsafe { core::mem::ManuallyDrop::take(&mut self.ptr_read_union().Block) }
    }

    pub fn is_Layout(&self) -> bool {
        matches!(self.discriminant(), discriminant_Elem::Layout)
    }

    pub fn Layout(f0: roc_std::RocList<Elem>, f1: LayoutConfig) -> Self {
        let tag_id = discriminant_Elem::Layout;

        let payload = Elem_Layout { f0, f1 } ;

        let union_payload = union_Elem { Layout: core::mem::ManuallyDrop::new(payload) };

        let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(union_payload)) };

        Self((ptr as usize | tag_id as usize) as *mut _)
    }

    pub fn get_Layout(mut self) -> Elem_Layout {
        debug_assert!(self.is_Layout());

        unsafe { core::mem::ManuallyDrop::take(&mut self.ptr_read_union().Layout) }
    }

    pub fn is_ListItems(&self) -> bool {
        matches!(self.discriminant(), discriminant_Elem::ListItems)
    }

    pub fn ListItems(f0: ListConfig) -> Self {
        let tag_id = discriminant_Elem::ListItems;

        let payload = Elem_ListItems { f0 } ;

        let union_payload = union_Elem { ListItems: core::mem::ManuallyDrop::new(payload) };

        let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(union_payload)) };

        Self((ptr as usize | tag_id as usize) as *mut _)
    }

    pub fn get_ListItems(mut self) -> Elem_ListItems {
        debug_assert!(self.is_ListItems());

        unsafe { core::mem::ManuallyDrop::take(&mut self.ptr_read_union().ListItems) }
    }

    pub fn is_Paragraph(&self) -> bool {
        matches!(self.discriminant(), discriminant_Elem::Paragraph)
    }

    pub fn Paragraph(f0: ParagraphConfig) -> Self {
        let tag_id = discriminant_Elem::Paragraph;

        let payload = Elem_Paragraph { f0 } ;

        let union_payload = union_Elem { Paragraph: core::mem::ManuallyDrop::new(payload) };

        let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(union_payload)) };

        Self((ptr as usize | tag_id as usize) as *mut _)
    }

    pub fn get_Paragraph(mut self) -> Elem_Paragraph {
        debug_assert!(self.is_Paragraph());

        unsafe { core::mem::ManuallyDrop::take(&mut self.ptr_read_union().Paragraph) }
    }
}

impl Clone for Elem {
    fn clone(&self) -> Self {
        use discriminant_Elem::*;

        let discriminant = self.discriminant();

        match discriminant {
                    Block => {
                let tag_id = discriminant_Elem::Block;

                let payload_union = unsafe { self.ptr_read_union() };
                let payload = union_Elem {
                    Block: unsafe { payload_union.Block.clone() },
                };

                let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(payload)) };

                Self((ptr as usize | tag_id as usize) as *mut _)
            },
            Layout => {
                let tag_id = discriminant_Elem::Layout;

                let payload_union = unsafe { self.ptr_read_union() };
                let payload = union_Elem {
                    Layout: unsafe { payload_union.Layout.clone() },
                };

                let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(payload)) };

                Self((ptr as usize | tag_id as usize) as *mut _)
            },
            ListItems => {
                let tag_id = discriminant_Elem::ListItems;

                let payload_union = unsafe { self.ptr_read_union() };
                let payload = union_Elem {
                    ListItems: unsafe { payload_union.ListItems.clone() },
                };

                let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(payload)) };

                Self((ptr as usize | tag_id as usize) as *mut _)
            },
            Paragraph => {
                let tag_id = discriminant_Elem::Paragraph;

                let payload_union = unsafe { self.ptr_read_union() };
                let payload = union_Elem {
                    Paragraph: unsafe { payload_union.Paragraph.clone() },
                };

                let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(payload)) };

                Self((ptr as usize | tag_id as usize) as *mut _)
            },
        }
    }
}

impl PartialEq for Elem {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_Elem::*;

        if self.discriminant() != other.discriminant() {
            return false;
        }

        match self.discriminant() {
                        Block => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.Block == payload_union2.Block
                }
            },
            Layout => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.Layout == payload_union2.Layout
                }
            },
            ListItems => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.ListItems == payload_union2.ListItems
                }
            },
            Paragraph => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.Paragraph == payload_union2.Paragraph
                }
            },
        }
    }
}

impl Eq for Elem {}

impl core::fmt::Debug for Elem {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Elem::*;

        match self.discriminant() {
                        Block => {
                let payload_union = unsafe { self.ptr_read_union() };

                unsafe {
                    f.debug_tuple("Elem::Block").field(&payload_union.Block.f0).finish()
                }
            },
            Layout => {
                let payload_union = unsafe { self.ptr_read_union() };

                unsafe {
                    f.debug_tuple("Elem::Layout").field(&payload_union.Layout.f0).field(&payload_union.Layout.f1).finish()
                }
            },
            ListItems => {
                let payload_union = unsafe { self.ptr_read_union() };

                unsafe {
                    f.debug_tuple("Elem::ListItems").field(&payload_union.ListItems.f0).finish()
                }
            },
            Paragraph => {
                let payload_union = unsafe { self.ptr_read_union() };

                unsafe {
                    f.debug_tuple("Elem::Paragraph").field(&payload_union.Paragraph.f0).finish()
                }
            },
        }
    }
}

impl core::hash::Hash for Elem {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_Elem::*;

        self.discriminant().hash(state);

        match self.discriminant() {
                        Block => {
                let payload_union = unsafe { self.ptr_read_union() };
                unsafe { payload_union.Block.hash(state) };
            },
            Layout => {
                let payload_union = unsafe { self.ptr_read_union() };
                unsafe { payload_union.Layout.hash(state) };
            },
            ListItems => {
                let payload_union = unsafe { self.ptr_read_union() };
                unsafe { payload_union.ListItems.hash(state) };
            },
            Paragraph => {
                let payload_union = unsafe { self.ptr_read_union() };
                unsafe { payload_union.Paragraph.hash(state) };
            },
        }
    }
}

impl PartialOrd for Elem {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(<Self as Ord>::cmp(self, other))
    }
}

impl Ord for Elem {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        use discriminant_Elem::*;

        use std::cmp::Ordering::*;

        match self.discriminant().cmp(&other.discriminant()) {
            Less => Less,
            Greater => Greater,
            Equal => unsafe {
                match self.discriminant() {
                                Block => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.Block.cmp(&payload_union2.Block)
                }
            },
            Layout => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.Layout.cmp(&payload_union2.Layout)
                }
            },
            ListItems => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.ListItems.cmp(&payload_union2.ListItems)
                }
            },
            Paragraph => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.Paragraph.cmp(&payload_union2.Paragraph)
                }
            },
                }
            },
        }
    }
}

#[repr(C)]
union union_Elem {    Block: core::mem::ManuallyDrop<Elem_Block>,
    Layout: core::mem::ManuallyDrop<Elem_Layout>,
    ListItems: core::mem::ManuallyDrop<Elem_ListItems>,
    Paragraph: core::mem::ManuallyDrop<Elem_Paragraph>,
    _sizer: [u8; 8],
}



#[repr(C)]
#[derive(Debug, Clone)]
pub struct RocFunction_70 {
    closure_data: roc_std::RocList<u8>,
}

impl RocFunction_70 {
    pub fn force_thunk(mut self, arg0: ()) -> roc_std::RocList<Elem> {
        extern "C" {
            fn roc__mainForHost_1_caller(arg0: *const (),  closure_data: *mut u8, output: *mut roc_std::RocList<Elem>);
        }

        let mut output = std::mem::MaybeUninit::uninit();
        let ptr = &mut self.closure_data as *mut _ as *mut u8;

        unsafe { roc__mainForHost_1_caller(&arg0,  ptr, output.as_mut_ptr(), ) };

        // ownership of the closure is transferred back to roc
        core::mem::forget(self.closure_data);

        unsafe { output.assume_init() }
    }
}#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum MediaKeyCode {
    FastForward = 0,
    LowerVolume = 1,
    MuteVolume = 2,
    Pause = 3,
    Play = 4,
    PlayPause = 5,
    RaiseVolume = 6,
    Record = 7,
    Reverse = 8,
    Rewind = 9,
    Stop = 10,
    TrackNext = 11,
    TrackPrevious = 12,
}

impl core::fmt::Debug for MediaKeyCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::FastForward => f.write_str("MediaKeyCode::FastForward"),
            Self::LowerVolume => f.write_str("MediaKeyCode::LowerVolume"),
            Self::MuteVolume => f.write_str("MediaKeyCode::MuteVolume"),
            Self::Pause => f.write_str("MediaKeyCode::Pause"),
            Self::Play => f.write_str("MediaKeyCode::Play"),
            Self::PlayPause => f.write_str("MediaKeyCode::PlayPause"),
            Self::RaiseVolume => f.write_str("MediaKeyCode::RaiseVolume"),
            Self::Record => f.write_str("MediaKeyCode::Record"),
            Self::Reverse => f.write_str("MediaKeyCode::Reverse"),
            Self::Rewind => f.write_str("MediaKeyCode::Rewind"),
            Self::Stop => f.write_str("MediaKeyCode::Stop"),
            Self::TrackNext => f.write_str("MediaKeyCode::TrackNext"),
            Self::TrackPrevious => f.write_str("MediaKeyCode::TrackPrevious"),
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum ModifierKeyCode {
    IsoLevel3Shift = 0,
    IsoLevel5Shift = 1,
    LeftAlt = 2,
    LeftControl = 3,
    LeftHyper = 4,
    LeftMeta = 5,
    LeftShift = 6,
    LeftSuper = 7,
    RightAlt = 8,
    RightControl = 9,
    RightHyper = 10,
    RightMeta = 11,
    RightShift = 12,
    RightSuper = 13,
}

impl core::fmt::Debug for ModifierKeyCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::IsoLevel3Shift => f.write_str("ModifierKeyCode::IsoLevel3Shift"),
            Self::IsoLevel5Shift => f.write_str("ModifierKeyCode::IsoLevel5Shift"),
            Self::LeftAlt => f.write_str("ModifierKeyCode::LeftAlt"),
            Self::LeftControl => f.write_str("ModifierKeyCode::LeftControl"),
            Self::LeftHyper => f.write_str("ModifierKeyCode::LeftHyper"),
            Self::LeftMeta => f.write_str("ModifierKeyCode::LeftMeta"),
            Self::LeftShift => f.write_str("ModifierKeyCode::LeftShift"),
            Self::LeftSuper => f.write_str("ModifierKeyCode::LeftSuper"),
            Self::RightAlt => f.write_str("ModifierKeyCode::RightAlt"),
            Self::RightControl => f.write_str("ModifierKeyCode::RightControl"),
            Self::RightHyper => f.write_str("ModifierKeyCode::RightHyper"),
            Self::RightMeta => f.write_str("ModifierKeyCode::RightMeta"),
            Self::RightShift => f.write_str("ModifierKeyCode::RightShift"),
            Self::RightSuper => f.write_str("ModifierKeyCode::RightSuper"),
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_KeyCode {
    BackTab = 0,
    Backspace = 1,
    CapsLock = 2,
    Delete = 3,
    Down = 4,
    End = 5,
    Enter = 6,
    Esc = 7,
    Function = 8,
    Home = 9,
    Insert = 10,
    KeypadBegin = 11,
    Left = 12,
    Media = 13,
    Menu = 14,
    Modifier = 15,
    Null = 16,
    NumLock = 17,
    PageDown = 18,
    PageUp = 19,
    Pause = 20,
    PrintScreen = 21,
    Right = 22,
    Scalar = 23,
    ScrollLock = 24,
    Tab = 25,
    Up = 26,
}

impl core::fmt::Debug for discriminant_KeyCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::BackTab => f.write_str("discriminant_KeyCode::BackTab"),
            Self::Backspace => f.write_str("discriminant_KeyCode::Backspace"),
            Self::CapsLock => f.write_str("discriminant_KeyCode::CapsLock"),
            Self::Delete => f.write_str("discriminant_KeyCode::Delete"),
            Self::Down => f.write_str("discriminant_KeyCode::Down"),
            Self::End => f.write_str("discriminant_KeyCode::End"),
            Self::Enter => f.write_str("discriminant_KeyCode::Enter"),
            Self::Esc => f.write_str("discriminant_KeyCode::Esc"),
            Self::Function => f.write_str("discriminant_KeyCode::Function"),
            Self::Home => f.write_str("discriminant_KeyCode::Home"),
            Self::Insert => f.write_str("discriminant_KeyCode::Insert"),
            Self::KeypadBegin => f.write_str("discriminant_KeyCode::KeypadBegin"),
            Self::Left => f.write_str("discriminant_KeyCode::Left"),
            Self::Media => f.write_str("discriminant_KeyCode::Media"),
            Self::Menu => f.write_str("discriminant_KeyCode::Menu"),
            Self::Modifier => f.write_str("discriminant_KeyCode::Modifier"),
            Self::Null => f.write_str("discriminant_KeyCode::Null"),
            Self::NumLock => f.write_str("discriminant_KeyCode::NumLock"),
            Self::PageDown => f.write_str("discriminant_KeyCode::PageDown"),
            Self::PageUp => f.write_str("discriminant_KeyCode::PageUp"),
            Self::Pause => f.write_str("discriminant_KeyCode::Pause"),
            Self::PrintScreen => f.write_str("discriminant_KeyCode::PrintScreen"),
            Self::Right => f.write_str("discriminant_KeyCode::Right"),
            Self::Scalar => f.write_str("discriminant_KeyCode::Scalar"),
            Self::ScrollLock => f.write_str("discriminant_KeyCode::ScrollLock"),
            Self::Tab => f.write_str("discriminant_KeyCode::Tab"),
            Self::Up => f.write_str("discriminant_KeyCode::Up"),
        }
    }
}

#[repr(C, align(8))]
pub union union_KeyCode {
    BackTab: (),
    Backspace: (),
    CapsLock: (),
    Delete: (),
    Down: (),
    End: (),
    Enter: (),
    Esc: (),
    Function: u8,
    Home: (),
    Insert: (),
    KeypadBegin: (),
    Left: (),
    Media: MediaKeyCode,
    Menu: (),
    Modifier: ModifierKeyCode,
    Null: (),
    NumLock: (),
    PageDown: (),
    PageUp: (),
    Pause: (),
    PrintScreen: (),
    Right: (),
    Scalar: core::mem::ManuallyDrop<roc_std::RocStr>,
    ScrollLock: (),
    Tab: (),
    Up: (),
}

const _SIZE_CHECK_union_KeyCode: () = assert!(core::mem::size_of::<union_KeyCode>() == 24);
const _ALIGN_CHECK_union_KeyCode: () = assert!(core::mem::align_of::<union_KeyCode>() == 8);

const _SIZE_CHECK_KeyCode: () = assert!(core::mem::size_of::<KeyCode>() == 32);
const _ALIGN_CHECK_KeyCode: () = assert!(core::mem::align_of::<KeyCode>() == 8);

impl KeyCode {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_KeyCode {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_KeyCode>(*bytes.as_ptr().add(24))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_KeyCode) {
        let discriminant_ptr: *mut discriminant_KeyCode = (self as *mut KeyCode).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct KeyCode {
    payload: union_KeyCode,
    discriminant: discriminant_KeyCode,
}

impl Clone for KeyCode {
    fn clone(&self) -> Self {
        use discriminant_KeyCode::*;

        let payload = unsafe {
            match self.discriminant {
                BackTab => union_KeyCode {
                    BackTab: self.payload.BackTab.clone(),
                },
                Backspace => union_KeyCode {
                    Backspace: self.payload.Backspace.clone(),
                },
                CapsLock => union_KeyCode {
                    CapsLock: self.payload.CapsLock.clone(),
                },
                Delete => union_KeyCode {
                    Delete: self.payload.Delete.clone(),
                },
                Down => union_KeyCode {
                    Down: self.payload.Down.clone(),
                },
                End => union_KeyCode {
                    End: self.payload.End.clone(),
                },
                Enter => union_KeyCode {
                    Enter: self.payload.Enter.clone(),
                },
                Esc => union_KeyCode {
                    Esc: self.payload.Esc.clone(),
                },
                Function => union_KeyCode {
                    Function: self.payload.Function.clone(),
                },
                Home => union_KeyCode {
                    Home: self.payload.Home.clone(),
                },
                Insert => union_KeyCode {
                    Insert: self.payload.Insert.clone(),
                },
                KeypadBegin => union_KeyCode {
                    KeypadBegin: self.payload.KeypadBegin.clone(),
                },
                Left => union_KeyCode {
                    Left: self.payload.Left.clone(),
                },
                Media => union_KeyCode {
                    Media: self.payload.Media.clone(),
                },
                Menu => union_KeyCode {
                    Menu: self.payload.Menu.clone(),
                },
                Modifier => union_KeyCode {
                    Modifier: self.payload.Modifier.clone(),
                },
                Null => union_KeyCode {
                    Null: self.payload.Null.clone(),
                },
                NumLock => union_KeyCode {
                    NumLock: self.payload.NumLock.clone(),
                },
                PageDown => union_KeyCode {
                    PageDown: self.payload.PageDown.clone(),
                },
                PageUp => union_KeyCode {
                    PageUp: self.payload.PageUp.clone(),
                },
                Pause => union_KeyCode {
                    Pause: self.payload.Pause.clone(),
                },
                PrintScreen => union_KeyCode {
                    PrintScreen: self.payload.PrintScreen.clone(),
                },
                Right => union_KeyCode {
                    Right: self.payload.Right.clone(),
                },
                Scalar => union_KeyCode {
                    Scalar: self.payload.Scalar.clone(),
                },
                ScrollLock => union_KeyCode {
                    ScrollLock: self.payload.ScrollLock.clone(),
                },
                Tab => union_KeyCode {
                    Tab: self.payload.Tab.clone(),
                },
                Up => union_KeyCode {
                    Up: self.payload.Up.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for KeyCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_KeyCode::*;

        unsafe {
            match self.discriminant {
                BackTab => {
                    let field: &() = &self.payload.BackTab;
                    f.debug_tuple("KeyCode::BackTab").field(field).finish()
                },
                Backspace => {
                    let field: &() = &self.payload.Backspace;
                    f.debug_tuple("KeyCode::Backspace").field(field).finish()
                },
                CapsLock => {
                    let field: &() = &self.payload.CapsLock;
                    f.debug_tuple("KeyCode::CapsLock").field(field).finish()
                },
                Delete => {
                    let field: &() = &self.payload.Delete;
                    f.debug_tuple("KeyCode::Delete").field(field).finish()
                },
                Down => {
                    let field: &() = &self.payload.Down;
                    f.debug_tuple("KeyCode::Down").field(field).finish()
                },
                End => {
                    let field: &() = &self.payload.End;
                    f.debug_tuple("KeyCode::End").field(field).finish()
                },
                Enter => {
                    let field: &() = &self.payload.Enter;
                    f.debug_tuple("KeyCode::Enter").field(field).finish()
                },
                Esc => {
                    let field: &() = &self.payload.Esc;
                    f.debug_tuple("KeyCode::Esc").field(field).finish()
                },
                Function => {
                    let field: &u8 = &self.payload.Function;
                    f.debug_tuple("KeyCode::Function").field(field).finish()
                },
                Home => {
                    let field: &() = &self.payload.Home;
                    f.debug_tuple("KeyCode::Home").field(field).finish()
                },
                Insert => {
                    let field: &() = &self.payload.Insert;
                    f.debug_tuple("KeyCode::Insert").field(field).finish()
                },
                KeypadBegin => {
                    let field: &() = &self.payload.KeypadBegin;
                    f.debug_tuple("KeyCode::KeypadBegin").field(field).finish()
                },
                Left => {
                    let field: &() = &self.payload.Left;
                    f.debug_tuple("KeyCode::Left").field(field).finish()
                },
                Media => {
                    let field: &MediaKeyCode = &self.payload.Media;
                    f.debug_tuple("KeyCode::Media").field(field).finish()
                },
                Menu => {
                    let field: &() = &self.payload.Menu;
                    f.debug_tuple("KeyCode::Menu").field(field).finish()
                },
                Modifier => {
                    let field: &ModifierKeyCode = &self.payload.Modifier;
                    f.debug_tuple("KeyCode::Modifier").field(field).finish()
                },
                Null => {
                    let field: &() = &self.payload.Null;
                    f.debug_tuple("KeyCode::Null").field(field).finish()
                },
                NumLock => {
                    let field: &() = &self.payload.NumLock;
                    f.debug_tuple("KeyCode::NumLock").field(field).finish()
                },
                PageDown => {
                    let field: &() = &self.payload.PageDown;
                    f.debug_tuple("KeyCode::PageDown").field(field).finish()
                },
                PageUp => {
                    let field: &() = &self.payload.PageUp;
                    f.debug_tuple("KeyCode::PageUp").field(field).finish()
                },
                Pause => {
                    let field: &() = &self.payload.Pause;
                    f.debug_tuple("KeyCode::Pause").field(field).finish()
                },
                PrintScreen => {
                    let field: &() = &self.payload.PrintScreen;
                    f.debug_tuple("KeyCode::PrintScreen").field(field).finish()
                },
                Right => {
                    let field: &() = &self.payload.Right;
                    f.debug_tuple("KeyCode::Right").field(field).finish()
                },
                Scalar => {
                    let field: &roc_std::RocStr = &self.payload.Scalar;
                    f.debug_tuple("KeyCode::Scalar").field(field).finish()
                },
                ScrollLock => {
                    let field: &() = &self.payload.ScrollLock;
                    f.debug_tuple("KeyCode::ScrollLock").field(field).finish()
                },
                Tab => {
                    let field: &() = &self.payload.Tab;
                    f.debug_tuple("KeyCode::Tab").field(field).finish()
                },
                Up => {
                    let field: &() = &self.payload.Up;
                    f.debug_tuple("KeyCode::Up").field(field).finish()
                },
            }
        }
    }
}

impl Eq for KeyCode {}

impl PartialEq for KeyCode {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_KeyCode::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                BackTab => self.payload.BackTab == other.payload.BackTab,
                Backspace => self.payload.Backspace == other.payload.Backspace,
                CapsLock => self.payload.CapsLock == other.payload.CapsLock,
                Delete => self.payload.Delete == other.payload.Delete,
                Down => self.payload.Down == other.payload.Down,
                End => self.payload.End == other.payload.End,
                Enter => self.payload.Enter == other.payload.Enter,
                Esc => self.payload.Esc == other.payload.Esc,
                Function => self.payload.Function == other.payload.Function,
                Home => self.payload.Home == other.payload.Home,
                Insert => self.payload.Insert == other.payload.Insert,
                KeypadBegin => self.payload.KeypadBegin == other.payload.KeypadBegin,
                Left => self.payload.Left == other.payload.Left,
                Media => self.payload.Media == other.payload.Media,
                Menu => self.payload.Menu == other.payload.Menu,
                Modifier => self.payload.Modifier == other.payload.Modifier,
                Null => self.payload.Null == other.payload.Null,
                NumLock => self.payload.NumLock == other.payload.NumLock,
                PageDown => self.payload.PageDown == other.payload.PageDown,
                PageUp => self.payload.PageUp == other.payload.PageUp,
                Pause => self.payload.Pause == other.payload.Pause,
                PrintScreen => self.payload.PrintScreen == other.payload.PrintScreen,
                Right => self.payload.Right == other.payload.Right,
                Scalar => self.payload.Scalar == other.payload.Scalar,
                ScrollLock => self.payload.ScrollLock == other.payload.ScrollLock,
                Tab => self.payload.Tab == other.payload.Tab,
                Up => self.payload.Up == other.payload.Up,
            }
        }
    }
}

impl Ord for KeyCode {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for KeyCode {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_KeyCode::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    BackTab => self.payload.BackTab.partial_cmp(&other.payload.BackTab),
                    Backspace => self.payload.Backspace.partial_cmp(&other.payload.Backspace),
                    CapsLock => self.payload.CapsLock.partial_cmp(&other.payload.CapsLock),
                    Delete => self.payload.Delete.partial_cmp(&other.payload.Delete),
                    Down => self.payload.Down.partial_cmp(&other.payload.Down),
                    End => self.payload.End.partial_cmp(&other.payload.End),
                    Enter => self.payload.Enter.partial_cmp(&other.payload.Enter),
                    Esc => self.payload.Esc.partial_cmp(&other.payload.Esc),
                    Function => self.payload.Function.partial_cmp(&other.payload.Function),
                    Home => self.payload.Home.partial_cmp(&other.payload.Home),
                    Insert => self.payload.Insert.partial_cmp(&other.payload.Insert),
                    KeypadBegin => self.payload.KeypadBegin.partial_cmp(&other.payload.KeypadBegin),
                    Left => self.payload.Left.partial_cmp(&other.payload.Left),
                    Media => self.payload.Media.partial_cmp(&other.payload.Media),
                    Menu => self.payload.Menu.partial_cmp(&other.payload.Menu),
                    Modifier => self.payload.Modifier.partial_cmp(&other.payload.Modifier),
                    Null => self.payload.Null.partial_cmp(&other.payload.Null),
                    NumLock => self.payload.NumLock.partial_cmp(&other.payload.NumLock),
                    PageDown => self.payload.PageDown.partial_cmp(&other.payload.PageDown),
                    PageUp => self.payload.PageUp.partial_cmp(&other.payload.PageUp),
                    Pause => self.payload.Pause.partial_cmp(&other.payload.Pause),
                    PrintScreen => self.payload.PrintScreen.partial_cmp(&other.payload.PrintScreen),
                    Right => self.payload.Right.partial_cmp(&other.payload.Right),
                    Scalar => self.payload.Scalar.partial_cmp(&other.payload.Scalar),
                    ScrollLock => self.payload.ScrollLock.partial_cmp(&other.payload.ScrollLock),
                    Tab => self.payload.Tab.partial_cmp(&other.payload.Tab),
                    Up => self.payload.Up.partial_cmp(&other.payload.Up),
                }
            },
        }
    }
}

impl core::hash::Hash for KeyCode {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_KeyCode::*;

        unsafe {
            match self.discriminant {
                BackTab => self.payload.BackTab.hash(state),
                Backspace => self.payload.Backspace.hash(state),
                CapsLock => self.payload.CapsLock.hash(state),
                Delete => self.payload.Delete.hash(state),
                Down => self.payload.Down.hash(state),
                End => self.payload.End.hash(state),
                Enter => self.payload.Enter.hash(state),
                Esc => self.payload.Esc.hash(state),
                Function => self.payload.Function.hash(state),
                Home => self.payload.Home.hash(state),
                Insert => self.payload.Insert.hash(state),
                KeypadBegin => self.payload.KeypadBegin.hash(state),
                Left => self.payload.Left.hash(state),
                Media => self.payload.Media.hash(state),
                Menu => self.payload.Menu.hash(state),
                Modifier => self.payload.Modifier.hash(state),
                Null => self.payload.Null.hash(state),
                NumLock => self.payload.NumLock.hash(state),
                PageDown => self.payload.PageDown.hash(state),
                PageUp => self.payload.PageUp.hash(state),
                Pause => self.payload.Pause.hash(state),
                PrintScreen => self.payload.PrintScreen.hash(state),
                Right => self.payload.Right.hash(state),
                Scalar => self.payload.Scalar.hash(state),
                ScrollLock => self.payload.ScrollLock.hash(state),
                Tab => self.payload.Tab.hash(state),
                Up => self.payload.Up.hash(state),
            }
        }
    }
}

impl KeyCode {

    pub fn is_BackTab(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::BackTab)
    }

    pub fn is_Backspace(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Backspace)
    }

    pub fn is_CapsLock(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::CapsLock)
    }

    pub fn is_Delete(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Delete)
    }

    pub fn is_Down(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Down)
    }

    pub fn is_End(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::End)
    }

    pub fn is_Enter(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Enter)
    }

    pub fn is_Esc(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Esc)
    }

    pub fn unwrap_Function(mut self) -> u8 {
        debug_assert_eq!(self.discriminant, discriminant_KeyCode::Function);
        unsafe { self.payload.Function }
    }

    pub fn is_Function(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Function)
    }

    pub fn is_Home(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Home)
    }

    pub fn is_Insert(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Insert)
    }

    pub fn is_KeypadBegin(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::KeypadBegin)
    }

    pub fn is_Left(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Left)
    }

    pub fn unwrap_Media(mut self) -> MediaKeyCode {
        debug_assert_eq!(self.discriminant, discriminant_KeyCode::Media);
        unsafe { self.payload.Media }
    }

    pub fn is_Media(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Media)
    }

    pub fn is_Menu(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Menu)
    }

    pub fn unwrap_Modifier(mut self) -> ModifierKeyCode {
        debug_assert_eq!(self.discriminant, discriminant_KeyCode::Modifier);
        unsafe { self.payload.Modifier }
    }

    pub fn is_Modifier(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Modifier)
    }

    pub fn is_Null(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Null)
    }

    pub fn is_NumLock(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::NumLock)
    }

    pub fn is_PageDown(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::PageDown)
    }

    pub fn is_PageUp(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::PageUp)
    }

    pub fn is_Pause(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Pause)
    }

    pub fn is_PrintScreen(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::PrintScreen)
    }

    pub fn is_Right(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Right)
    }

    pub fn unwrap_Scalar(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_KeyCode::Scalar);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Scalar) }
    }

    pub fn is_Scalar(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Scalar)
    }

    pub fn is_ScrollLock(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::ScrollLock)
    }

    pub fn is_Tab(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Tab)
    }

    pub fn is_Up(&self) -> bool {
        matches!(self.discriminant, discriminant_KeyCode::Up)
    }
}



impl KeyCode {

    pub fn BackTab() -> Self {
        Self {
            discriminant: discriminant_KeyCode::BackTab,
            payload: union_KeyCode {
                BackTab: (),
            }
        }
    }

    pub fn Backspace() -> Self {
        Self {
            discriminant: discriminant_KeyCode::Backspace,
            payload: union_KeyCode {
                Backspace: (),
            }
        }
    }

    pub fn CapsLock() -> Self {
        Self {
            discriminant: discriminant_KeyCode::CapsLock,
            payload: union_KeyCode {
                CapsLock: (),
            }
        }
    }

    pub fn Delete() -> Self {
        Self {
            discriminant: discriminant_KeyCode::Delete,
            payload: union_KeyCode {
                Delete: (),
            }
        }
    }

    pub fn Down() -> Self {
        Self {
            discriminant: discriminant_KeyCode::Down,
            payload: union_KeyCode {
                Down: (),
            }
        }
    }

    pub fn End() -> Self {
        Self {
            discriminant: discriminant_KeyCode::End,
            payload: union_KeyCode {
                End: (),
            }
        }
    }

    pub fn Enter() -> Self {
        Self {
            discriminant: discriminant_KeyCode::Enter,
            payload: union_KeyCode {
                Enter: (),
            }
        }
    }

    pub fn Esc() -> Self {
        Self {
            discriminant: discriminant_KeyCode::Esc,
            payload: union_KeyCode {
                Esc: (),
            }
        }
    }

    pub fn Function(payload: u8) -> Self {
        Self {
            discriminant: discriminant_KeyCode::Function,
            payload: union_KeyCode {
                Function: payload,
            }
        }
    }

    pub fn Home() -> Self {
        Self {
            discriminant: discriminant_KeyCode::Home,
            payload: union_KeyCode {
                Home: (),
            }
        }
    }

    pub fn Insert() -> Self {
        Self {
            discriminant: discriminant_KeyCode::Insert,
            payload: union_KeyCode {
                Insert: (),
            }
        }
    }

    pub fn KeypadBegin() -> Self {
        Self {
            discriminant: discriminant_KeyCode::KeypadBegin,
            payload: union_KeyCode {
                KeypadBegin: (),
            }
        }
    }

    pub fn Left() -> Self {
        Self {
            discriminant: discriminant_KeyCode::Left,
            payload: union_KeyCode {
                Left: (),
            }
        }
    }

    pub fn Media(payload: MediaKeyCode) -> Self {
        Self {
            discriminant: discriminant_KeyCode::Media,
            payload: union_KeyCode {
                Media: payload,
            }
        }
    }

    pub fn Menu() -> Self {
        Self {
            discriminant: discriminant_KeyCode::Menu,
            payload: union_KeyCode {
                Menu: (),
            }
        }
    }

    pub fn Modifier(payload: ModifierKeyCode) -> Self {
        Self {
            discriminant: discriminant_KeyCode::Modifier,
            payload: union_KeyCode {
                Modifier: payload,
            }
        }
    }

    pub fn Null() -> Self {
        Self {
            discriminant: discriminant_KeyCode::Null,
            payload: union_KeyCode {
                Null: (),
            }
        }
    }

    pub fn NumLock() -> Self {
        Self {
            discriminant: discriminant_KeyCode::NumLock,
            payload: union_KeyCode {
                NumLock: (),
            }
        }
    }

    pub fn PageDown() -> Self {
        Self {
            discriminant: discriminant_KeyCode::PageDown,
            payload: union_KeyCode {
                PageDown: (),
            }
        }
    }

    pub fn PageUp() -> Self {
        Self {
            discriminant: discriminant_KeyCode::PageUp,
            payload: union_KeyCode {
                PageUp: (),
            }
        }
    }

    pub fn Pause() -> Self {
        Self {
            discriminant: discriminant_KeyCode::Pause,
            payload: union_KeyCode {
                Pause: (),
            }
        }
    }

    pub fn PrintScreen() -> Self {
        Self {
            discriminant: discriminant_KeyCode::PrintScreen,
            payload: union_KeyCode {
                PrintScreen: (),
            }
        }
    }

    pub fn Right() -> Self {
        Self {
            discriminant: discriminant_KeyCode::Right,
            payload: union_KeyCode {
                Right: (),
            }
        }
    }

    pub fn Scalar(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_KeyCode::Scalar,
            payload: union_KeyCode {
                Scalar: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn ScrollLock() -> Self {
        Self {
            discriminant: discriminant_KeyCode::ScrollLock,
            payload: union_KeyCode {
                ScrollLock: (),
            }
        }
    }

    pub fn Tab() -> Self {
        Self {
            discriminant: discriminant_KeyCode::Tab,
            payload: union_KeyCode {
                Tab: (),
            }
        }
    }

    pub fn Up() -> Self {
        Self {
            discriminant: discriminant_KeyCode::Up,
            payload: union_KeyCode {
                Up: (),
            }
        }
    }
}

impl Drop for KeyCode {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_KeyCode::BackTab => {}
            discriminant_KeyCode::Backspace => {}
            discriminant_KeyCode::CapsLock => {}
            discriminant_KeyCode::Delete => {}
            discriminant_KeyCode::Down => {}
            discriminant_KeyCode::End => {}
            discriminant_KeyCode::Enter => {}
            discriminant_KeyCode::Esc => {}
            discriminant_KeyCode::Function => {}
            discriminant_KeyCode::Home => {}
            discriminant_KeyCode::Insert => {}
            discriminant_KeyCode::KeypadBegin => {}
            discriminant_KeyCode::Left => {}
            discriminant_KeyCode::Media => {}
            discriminant_KeyCode::Menu => {}
            discriminant_KeyCode::Modifier => {}
            discriminant_KeyCode::Null => {}
            discriminant_KeyCode::NumLock => {}
            discriminant_KeyCode::PageDown => {}
            discriminant_KeyCode::PageUp => {}
            discriminant_KeyCode::Pause => {}
            discriminant_KeyCode::PrintScreen => {}
            discriminant_KeyCode::Right => {}
            discriminant_KeyCode::Scalar => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Scalar) },
            discriminant_KeyCode::ScrollLock => {}
            discriminant_KeyCode::Tab => {}
            discriminant_KeyCode::Up => {}
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_Event {
    FocusGained = 0,
    FocusLost = 1,
    KeyPressed = 2,
    Paste = 3,
    Resize = 4,
    Tick = 5,
}

impl core::fmt::Debug for discriminant_Event {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::FocusGained => f.write_str("discriminant_Event::FocusGained"),
            Self::FocusLost => f.write_str("discriminant_Event::FocusLost"),
            Self::KeyPressed => f.write_str("discriminant_Event::KeyPressed"),
            Self::Paste => f.write_str("discriminant_Event::Paste"),
            Self::Resize => f.write_str("discriminant_Event::Resize"),
            Self::Tick => f.write_str("discriminant_Event::Tick"),
        }
    }
}

#[repr(C, align(8))]
pub union union_Event {
    FocusGained: (),
    FocusLost: (),
    KeyPressed: core::mem::ManuallyDrop<KeyCode>,
    Paste: core::mem::ManuallyDrop<roc_std::RocStr>,
    Resize: Bounds,
    Tick: (),
}

const _SIZE_CHECK_union_Event: () = assert!(core::mem::size_of::<union_Event>() == 32);
const _ALIGN_CHECK_union_Event: () = assert!(core::mem::align_of::<union_Event>() == 8);

const _SIZE_CHECK_Event: () = assert!(core::mem::size_of::<Event>() == 40);
const _ALIGN_CHECK_Event: () = assert!(core::mem::align_of::<Event>() == 8);

impl Event {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Event {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Event>(*bytes.as_ptr().add(32))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Event) {
        let discriminant_ptr: *mut discriminant_Event = (self as *mut Event).cast();

        unsafe {
            *(discriminant_ptr.add(32)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct Event {
    payload: union_Event,
    discriminant: discriminant_Event,
}

impl Clone for Event {
    fn clone(&self) -> Self {
        use discriminant_Event::*;

        let payload = unsafe {
            match self.discriminant {
                FocusGained => union_Event {
                    FocusGained: self.payload.FocusGained.clone(),
                },
                FocusLost => union_Event {
                    FocusLost: self.payload.FocusLost.clone(),
                },
                KeyPressed => union_Event {
                    KeyPressed: self.payload.KeyPressed.clone(),
                },
                Paste => union_Event {
                    Paste: self.payload.Paste.clone(),
                },
                Resize => union_Event {
                    Resize: self.payload.Resize.clone(),
                },
                Tick => union_Event {
                    Tick: self.payload.Tick.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for Event {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Event::*;

        unsafe {
            match self.discriminant {
                FocusGained => {
                    let field: &() = &self.payload.FocusGained;
                    f.debug_tuple("Event::FocusGained").field(field).finish()
                },
                FocusLost => {
                    let field: &() = &self.payload.FocusLost;
                    f.debug_tuple("Event::FocusLost").field(field).finish()
                },
                KeyPressed => {
                    let field: &KeyCode = &self.payload.KeyPressed;
                    f.debug_tuple("Event::KeyPressed").field(field).finish()
                },
                Paste => {
                    let field: &roc_std::RocStr = &self.payload.Paste;
                    f.debug_tuple("Event::Paste").field(field).finish()
                },
                Resize => {
                    let field: &Bounds = &self.payload.Resize;
                    f.debug_tuple("Event::Resize").field(field).finish()
                },
                Tick => {
                    let field: &() = &self.payload.Tick;
                    f.debug_tuple("Event::Tick").field(field).finish()
                },
            }
        }
    }
}

impl Eq for Event {}

impl PartialEq for Event {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_Event::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                FocusGained => self.payload.FocusGained == other.payload.FocusGained,
                FocusLost => self.payload.FocusLost == other.payload.FocusLost,
                KeyPressed => self.payload.KeyPressed == other.payload.KeyPressed,
                Paste => self.payload.Paste == other.payload.Paste,
                Resize => self.payload.Resize == other.payload.Resize,
                Tick => self.payload.Tick == other.payload.Tick,
            }
        }
    }
}

impl Ord for Event {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for Event {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_Event::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    FocusGained => self.payload.FocusGained.partial_cmp(&other.payload.FocusGained),
                    FocusLost => self.payload.FocusLost.partial_cmp(&other.payload.FocusLost),
                    KeyPressed => self.payload.KeyPressed.partial_cmp(&other.payload.KeyPressed),
                    Paste => self.payload.Paste.partial_cmp(&other.payload.Paste),
                    Resize => self.payload.Resize.partial_cmp(&other.payload.Resize),
                    Tick => self.payload.Tick.partial_cmp(&other.payload.Tick),
                }
            },
        }
    }
}

impl core::hash::Hash for Event {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_Event::*;

        unsafe {
            match self.discriminant {
                FocusGained => self.payload.FocusGained.hash(state),
                FocusLost => self.payload.FocusLost.hash(state),
                KeyPressed => self.payload.KeyPressed.hash(state),
                Paste => self.payload.Paste.hash(state),
                Resize => self.payload.Resize.hash(state),
                Tick => self.payload.Tick.hash(state),
            }
        }
    }
}

impl Event {

    pub fn is_FocusGained(&self) -> bool {
        matches!(self.discriminant, discriminant_Event::FocusGained)
    }

    pub fn is_FocusLost(&self) -> bool {
        matches!(self.discriminant, discriminant_Event::FocusLost)
    }

    pub fn unwrap_KeyPressed(mut self) -> KeyCode {
        debug_assert_eq!(self.discriminant, discriminant_Event::KeyPressed);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.KeyPressed) }
    }

    pub fn is_KeyPressed(&self) -> bool {
        matches!(self.discriminant, discriminant_Event::KeyPressed)
    }

    pub fn unwrap_Paste(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Event::Paste);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Paste) }
    }

    pub fn is_Paste(&self) -> bool {
        matches!(self.discriminant, discriminant_Event::Paste)
    }

    pub fn unwrap_Resize(mut self) -> Bounds {
        debug_assert_eq!(self.discriminant, discriminant_Event::Resize);
        unsafe { self.payload.Resize }
    }

    pub fn is_Resize(&self) -> bool {
        matches!(self.discriminant, discriminant_Event::Resize)
    }

    pub fn is_Tick(&self) -> bool {
        matches!(self.discriminant, discriminant_Event::Tick)
    }
}



impl Event {

    pub fn FocusGained() -> Self {
        Self {
            discriminant: discriminant_Event::FocusGained,
            payload: union_Event {
                FocusGained: (),
            }
        }
    }

    pub fn FocusLost() -> Self {
        Self {
            discriminant: discriminant_Event::FocusLost,
            payload: union_Event {
                FocusLost: (),
            }
        }
    }

    pub fn KeyPressed(payload: KeyCode) -> Self {
        Self {
            discriminant: discriminant_Event::KeyPressed,
            payload: union_Event {
                KeyPressed: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Paste(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_Event::Paste,
            payload: union_Event {
                Paste: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Resize(payload: Bounds) -> Self {
        Self {
            discriminant: discriminant_Event::Resize,
            payload: union_Event {
                Resize: payload,
            }
        }
    }

    pub fn Tick() -> Self {
        Self {
            discriminant: discriminant_Event::Tick,
            payload: union_Event {
                Tick: (),
            }
        }
    }
}

impl Drop for Event {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Event::FocusGained => {}
            discriminant_Event::FocusLost => {}
            discriminant_Event::KeyPressed => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.KeyPressed) },
            discriminant_Event::Paste => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Paste) },
            discriminant_Event::Resize => {}
            discriminant_Event::Tick => {}
        }
    }
}



#[repr(C)]
#[derive(Debug, Clone)]
pub struct RocFunction_68 {
    closure_data: roc_std::RocList<u8>,
}

impl RocFunction_68 {
    pub fn force_thunk(mut self, arg0: (), arg1: Event) -> () {
        extern "C" {
            fn roc__mainForHost_2_caller(arg0: *const (), arg1: *const Event,  closure_data: *mut u8, output: *mut ());
        }

        let mut output = std::mem::MaybeUninit::uninit();
        let ptr = &mut self.closure_data as *mut _ as *mut u8;

        unsafe { roc__mainForHost_2_caller(&arg0, &arg1,  ptr, output.as_mut_ptr(), ) };

        // ownership of the closure is transferred back to roc
        core::mem::forget(self.closure_data);

        unsafe { output.assume_init() }
    }
}#[derive(Clone, Debug, )]
#[repr(C)]
pub struct R1 {
    pub init: RocFunction_66,
    pub render: RocFunction_70,
    pub update: RocFunction_68,
}



pub fn programForHost() -> R1 {
    extern "C" {
        fn roc__programForHost_1_exposed_generic(_: *mut R1);
    }

    let mut ret = std::mem::MaybeUninit::uninit();

    unsafe { roc__programForHost_1_exposed_generic(ret.as_mut_ptr(), ) };

    unsafe { ret.assume_init() }
}