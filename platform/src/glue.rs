// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_Elem {
    Block = 0,
    Layout = 1,
    ListItems = 2,
    Paragraph = 3,
}

impl core::fmt::Debug for discriminant_Elem {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Block => f.write_str("discriminant_Elem::Block"),
            Self::Layout => f.write_str("discriminant_Elem::Layout"),
            Self::ListItems => f.write_str("discriminant_Elem::ListItems"),
            Self::Paragraph => f.write_str("discriminant_Elem::Paragraph"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(transparent)]
pub struct Elem {
    pointer: *mut union_Elem,
}


#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[repr(C)]
union union_Elem {
    Block: core::mem::ManuallyDrop<Elem_Block>,
    Layout: core::mem::ManuallyDrop<Elem_Layout>,
    ListItems: core::mem::ManuallyDrop<Elem_ListItems>,
    Paragraph: core::mem::ManuallyDrop<Elem_Paragraph>,
    _sizer: [u8; 4],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Span {
    pub style: Style,
    pub text: roc_std::RocStr,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_Event {
    FocusGained = 0,
    FocusLost = 1,
    KeyPressed = 2,
    Paste = 3,
    Resize = 4,
    Tick = 5,
}

impl core::fmt::Debug for discriminant_Event {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::FocusGained => f.write_str("discriminant_Event::FocusGained"),
            Self::FocusLost => f.write_str("discriminant_Event::FocusLost"),
            Self::KeyPressed => f.write_str("discriminant_Event::KeyPressed"),
            Self::Paste => f.write_str("discriminant_Event::Paste"),
            Self::Resize => f.write_str("discriminant_Event::Resize"),
            Self::Tick => f.write_str("discriminant_Event::Tick"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[repr(C)]
pub union Event {
    KeyPressed: core::mem::ManuallyDrop<KeyCode>,
    Paste: core::mem::ManuallyDrop<roc_std::RocStr>,
    Resize: Bounds,
    _sizer: [u8; 20],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_Constraint {
    Length = 0,
    Max = 1,
    Min = 2,
    Percentage = 3,
    Ratio = 4,
}

impl core::fmt::Debug for discriminant_Constraint {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Length => f.write_str("discriminant_Constraint::Length"),
            Self::Max => f.write_str("discriminant_Constraint::Max"),
            Self::Min => f.write_str("discriminant_Constraint::Min"),
            Self::Percentage => f.write_str("discriminant_Constraint::Percentage"),
            Self::Ratio => f.write_str("discriminant_Constraint::Ratio"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union Constraint {
    Length: u16,
    Max: u16,
    Min: u16,
    Percentage: u16,
    Ratio: Constraint_Ratio,
    _sizer: [u8; 12],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum BorderModifier {
    All = 0,
    Bottom = 1,
    Left = 2,
    None = 3,
    Right = 4,
    Top = 5,
}

impl core::fmt::Debug for BorderModifier {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::All => f.write_str("BorderModifier::All"),
            Self::Bottom => f.write_str("BorderModifier::Bottom"),
            Self::Left => f.write_str("BorderModifier::Left"),
            Self::None => f.write_str("BorderModifier::None"),
            Self::Right => f.write_str("BorderModifier::Right"),
            Self::Top => f.write_str("BorderModifier::Top"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum TextModifier {
    Bold = 0,
    CrossedOut = 1,
    Dim = 2,
    Hidden = 3,
    Italic = 4,
    RapidBlink = 5,
    Reversed = 6,
    SlowBlink = 7,
    Underlined = 8,
}

impl core::fmt::Debug for TextModifier {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Bold => f.write_str("TextModifier::Bold"),
            Self::CrossedOut => f.write_str("TextModifier::CrossedOut"),
            Self::Dim => f.write_str("TextModifier::Dim"),
            Self::Hidden => f.write_str("TextModifier::Hidden"),
            Self::Italic => f.write_str("TextModifier::Italic"),
            Self::RapidBlink => f.write_str("TextModifier::RapidBlink"),
            Self::Reversed => f.write_str("TextModifier::Reversed"),
            Self::SlowBlink => f.write_str("TextModifier::SlowBlink"),
            Self::Underlined => f.write_str("TextModifier::Underlined"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Bounds {
    pub height: u16,
    pub width: u16,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R1 {
    // pub init: TODO_roc_function_65,
    // pub render: TODO_roc_function_69,
    // pub update: TODO_roc_function_67,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_KeyCode {
    BackTab = 0,
    Backspace = 1,
    CapsLock = 2,
    Delete = 3,
    Down = 4,
    End = 5,
    Enter = 6,
    Esc = 7,
    Function = 8,
    Home = 9,
    Insert = 10,
    KeypadBegin = 11,
    Left = 12,
    Media = 13,
    Menu = 14,
    Modifier = 15,
    Null = 16,
    NumLock = 17,
    PageDown = 18,
    PageUp = 19,
    Pause = 20,
    PrintScreen = 21,
    Right = 22,
    Scalar = 23,
    ScrollLock = 24,
    Tab = 25,
    Up = 26,
}

impl core::fmt::Debug for discriminant_KeyCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::BackTab => f.write_str("discriminant_KeyCode::BackTab"),
            Self::Backspace => f.write_str("discriminant_KeyCode::Backspace"),
            Self::CapsLock => f.write_str("discriminant_KeyCode::CapsLock"),
            Self::Delete => f.write_str("discriminant_KeyCode::Delete"),
            Self::Down => f.write_str("discriminant_KeyCode::Down"),
            Self::End => f.write_str("discriminant_KeyCode::End"),
            Self::Enter => f.write_str("discriminant_KeyCode::Enter"),
            Self::Esc => f.write_str("discriminant_KeyCode::Esc"),
            Self::Function => f.write_str("discriminant_KeyCode::Function"),
            Self::Home => f.write_str("discriminant_KeyCode::Home"),
            Self::Insert => f.write_str("discriminant_KeyCode::Insert"),
            Self::KeypadBegin => f.write_str("discriminant_KeyCode::KeypadBegin"),
            Self::Left => f.write_str("discriminant_KeyCode::Left"),
            Self::Media => f.write_str("discriminant_KeyCode::Media"),
            Self::Menu => f.write_str("discriminant_KeyCode::Menu"),
            Self::Modifier => f.write_str("discriminant_KeyCode::Modifier"),
            Self::Null => f.write_str("discriminant_KeyCode::Null"),
            Self::NumLock => f.write_str("discriminant_KeyCode::NumLock"),
            Self::PageDown => f.write_str("discriminant_KeyCode::PageDown"),
            Self::PageUp => f.write_str("discriminant_KeyCode::PageUp"),
            Self::Pause => f.write_str("discriminant_KeyCode::Pause"),
            Self::PrintScreen => f.write_str("discriminant_KeyCode::PrintScreen"),
            Self::Right => f.write_str("discriminant_KeyCode::Right"),
            Self::Scalar => f.write_str("discriminant_KeyCode::Scalar"),
            Self::ScrollLock => f.write_str("discriminant_KeyCode::ScrollLock"),
            Self::Tab => f.write_str("discriminant_KeyCode::Tab"),
            Self::Up => f.write_str("discriminant_KeyCode::Up"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[repr(C)]
pub union KeyCode {
    Function: u8,
    Media: MediaKeyCode,
    Modifier: ModifierKeyCode,
    Scalar: core::mem::ManuallyDrop<roc_std::RocStr>,
    _sizer: [u8; 16],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum ModifierKeyCode {
    IsoLevel3Shift = 0,
    IsoLevel5Shift = 1,
    LeftAlt = 2,
    LeftControl = 3,
    LeftHyper = 4,
    LeftMeta = 5,
    LeftShift = 6,
    LeftSuper = 7,
    RightAlt = 8,
    RightControl = 9,
    RightHyper = 10,
    RightMeta = 11,
    RightShift = 12,
    RightSuper = 13,
}

impl core::fmt::Debug for ModifierKeyCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::IsoLevel3Shift => f.write_str("ModifierKeyCode::IsoLevel3Shift"),
            Self::IsoLevel5Shift => f.write_str("ModifierKeyCode::IsoLevel5Shift"),
            Self::LeftAlt => f.write_str("ModifierKeyCode::LeftAlt"),
            Self::LeftControl => f.write_str("ModifierKeyCode::LeftControl"),
            Self::LeftHyper => f.write_str("ModifierKeyCode::LeftHyper"),
            Self::LeftMeta => f.write_str("ModifierKeyCode::LeftMeta"),
            Self::LeftShift => f.write_str("ModifierKeyCode::LeftShift"),
            Self::LeftSuper => f.write_str("ModifierKeyCode::LeftSuper"),
            Self::RightAlt => f.write_str("ModifierKeyCode::RightAlt"),
            Self::RightControl => f.write_str("ModifierKeyCode::RightControl"),
            Self::RightHyper => f.write_str("ModifierKeyCode::RightHyper"),
            Self::RightMeta => f.write_str("ModifierKeyCode::RightMeta"),
            Self::RightShift => f.write_str("ModifierKeyCode::RightShift"),
            Self::RightSuper => f.write_str("ModifierKeyCode::RightSuper"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum MediaKeyCode {
    FastForward = 0,
    LowerVolume = 1,
    MuteVolume = 2,
    Pause = 3,
    Play = 4,
    PlayPause = 5,
    RaiseVolume = 6,
    Record = 7,
    Reverse = 8,
    Rewind = 9,
    Stop = 10,
    TrackNext = 11,
    TrackPrevious = 12,
}

impl core::fmt::Debug for MediaKeyCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::FastForward => f.write_str("MediaKeyCode::FastForward"),
            Self::LowerVolume => f.write_str("MediaKeyCode::LowerVolume"),
            Self::MuteVolume => f.write_str("MediaKeyCode::MuteVolume"),
            Self::Pause => f.write_str("MediaKeyCode::Pause"),
            Self::Play => f.write_str("MediaKeyCode::Play"),
            Self::PlayPause => f.write_str("MediaKeyCode::PlayPause"),
            Self::RaiseVolume => f.write_str("MediaKeyCode::RaiseVolume"),
            Self::Record => f.write_str("MediaKeyCode::Record"),
            Self::Reverse => f.write_str("MediaKeyCode::Reverse"),
            Self::Rewind => f.write_str("MediaKeyCode::Rewind"),
            Self::Stop => f.write_str("MediaKeyCode::Stop"),
            Self::TrackNext => f.write_str("MediaKeyCode::TrackNext"),
            Self::TrackPrevious => f.write_str("MediaKeyCode::TrackPrevious"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
struct Elem_Paragraph {
    pub f0: ParagraphConfig,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct ParagraphConfig {
    pub block: BlockConfig,
    pub text: roc_std::RocList<roc_std::RocList<Span>>,
    pub cursor: Cursor,
    pub scroll: u16,
    pub textAlignment: Alignment,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_Cursor {
    At = 0,
    Hidden = 1,
}

impl core::fmt::Debug for discriminant_Cursor {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::At => f.write_str("discriminant_Cursor::At"),
            Self::Hidden => f.write_str("discriminant_Cursor::Hidden"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union Cursor {
    At: CursorPosition,
    _sizer: [u8; 6],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct CursorPosition {
    pub col: u16,
    pub row: u16,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
struct Elem_ListItems {
    pub f0: ListConfig,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct ListConfig {
    pub block: BlockConfig,
    pub highlightStyle: Style,
    pub highlightSymbol: roc_std::RocStr,
    pub items: roc_std::RocList<roc_std::RocList<Span>>,
    pub selected: ListSelection,
    pub style: Style,
    pub highlightSymbolRepeat: bool,
    pub startCorner: Corner,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum Corner {
    BottomLeft = 0,
    BottomRight = 1,
    TopLeft = 2,
    TopRight = 3,
}

impl core::fmt::Debug for Corner {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::BottomLeft => f.write_str("Corner::BottomLeft"),
            Self::BottomRight => f.write_str("Corner::BottomRight"),
            Self::TopLeft => f.write_str("Corner::TopLeft"),
            Self::TopRight => f.write_str("Corner::TopRight"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_ListSelection {
    None = 0,
    Selected = 1,
}

impl core::fmt::Debug for discriminant_ListSelection {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::None => f.write_str("discriminant_ListSelection::None"),
            Self::Selected => f.write_str("discriminant_ListSelection::Selected"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[repr(C)]
pub union ListSelection {
    Selected: u32,
    _sizer: [u8; 8],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct Elem_Layout {
    pub f0: roc_std::RocList<Elem>,
    pub f1: LayoutConfig,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct LayoutConfig {
    pub constraints: roc_std::RocList<Constraint>,
    pub hMargin: u16,
    pub popup: PopupConfig,
    pub vMargin: u16,
    pub direction: LayoutDirection,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum LayoutDirection {
    Horizontal = 0,
    Vertical = 1,
}

impl core::fmt::Debug for LayoutDirection {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Horizontal => f.write_str("LayoutDirection::Horizontal"),
            Self::Vertical => f.write_str("LayoutDirection::Vertical"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_PopupConfig {
    Centered = 0,
    None = 1,
}

impl core::fmt::Debug for discriminant_PopupConfig {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Centered => f.write_str("discriminant_PopupConfig::Centered"),
            Self::None => f.write_str("discriminant_PopupConfig::None"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union PopupConfig {
    Centered: ModalPosition,
    _sizer: [u8; 6],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct ModalPosition {
    pub percentX: u16,
    pub percentY: u16,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct Constraint_Ratio {
    pub f0: u32,
    pub f1: u32,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
struct Elem_Block {
    pub f0: BlockConfig,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct BlockConfig {
    pub borderStyle: Style,
    pub borders: roc_std::RocList<BorderModifier>,
    pub style: Style,
    pub title: Span,
    pub borderType: BorderType,
    pub titleAlignment: Alignment,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum Alignment {
    Center = 0,
    Left = 1,
    Right = 2,
}

impl core::fmt::Debug for Alignment {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Center => f.write_str("Alignment::Center"),
            Self::Left => f.write_str("Alignment::Left"),
            Self::Right => f.write_str("Alignment::Right"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum BorderType {
    Double = 0,
    Plain = 1,
    Rounded = 2,
    Thick = 3,
}

impl core::fmt::Debug for BorderType {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Double => f.write_str("BorderType::Double"),
            Self::Plain => f.write_str("BorderType::Plain"),
            Self::Rounded => f.write_str("BorderType::Rounded"),
            Self::Thick => f.write_str("BorderType::Thick"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Style {
    pub modifiers: roc_std::RocList<TextModifier>,
    pub bg: Color,
    pub fg: Color,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_Color {
    Black = 0,
    Blue = 1,
    Default = 2,
    Green = 3,
    Red = 4,
    Rgb = 5,
    White = 6,
}

impl core::fmt::Debug for discriminant_Color {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Black => f.write_str("discriminant_Color::Black"),
            Self::Blue => f.write_str("discriminant_Color::Blue"),
            Self::Default => f.write_str("discriminant_Color::Default"),
            Self::Green => f.write_str("discriminant_Color::Green"),
            Self::Red => f.write_str("discriminant_Color::Red"),
            Self::Rgb => f.write_str("discriminant_Color::Rgb"),
            Self::White => f.write_str("discriminant_Color::White"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union Color {
    Rgb: Color_Rgb,
    _sizer: [u8; 4],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct Color_Rgb {
    pub f0: u8,
    pub f1: u8,
    pub f2: u8,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[repr(C)]
union union_Elem {
    Block: core::mem::ManuallyDrop<Elem_Block>,
    Layout: core::mem::ManuallyDrop<Elem_Layout>,
    ListItems: core::mem::ManuallyDrop<Elem_ListItems>,
    Paragraph: core::mem::ManuallyDrop<Elem_Paragraph>,
    _sizer: [u8; 8],
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union Event {
    KeyPressed: core::mem::ManuallyDrop<KeyCode>,
    Paste: core::mem::ManuallyDrop<roc_std::RocStr>,
    Resize: Bounds,
    _sizer: [u8; 40],
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union KeyCode {
    Function: u8,
    Media: MediaKeyCode,
    Modifier: ModifierKeyCode,
    Scalar: core::mem::ManuallyDrop<roc_std::RocStr>,
    _sizer: [u8; 32],
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union ListSelection {
    Selected: u64,
    _sizer: [u8; 16],
}

impl Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    #[inline(always)]
    fn storage(&self) -> Option<&core::cell::Cell<roc_std::Storage>> {
        let mask = match std::mem::size_of::<usize>() {
            4 => 0b11,
            8 => 0b111,
            _ => unreachable!(),
        };

        // NOTE: pointer provenance is probably lost here
        let unmasked_address = (self.pointer as usize) & !mask;
        let untagged = unmasked_address as *const core::cell::Cell<roc_std::Storage>;

        if untagged.is_null() {
            None
        } else {
            unsafe {
                Some(&*untagged.sub(1))
            }
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Elem {
        // The discriminant is stored in the unused bytes at the end of the recursive pointer
        unsafe { core::mem::transmute::<u8, discriminant_Elem>((self.pointer as u8) & 0b11) }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn tag_discriminant(pointer: *mut union_Elem, discriminant: discriminant_Elem) -> *mut union_Elem {
        // The discriminant is stored in the unused bytes at the end of the union pointer
        let untagged = (pointer as usize) & (!0b11 as usize);
        let tagged = untagged | (discriminant as usize);

        tagged as *mut union_Elem
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn union_pointer(&self) -> *mut union_Elem {
        // The discriminant is stored in the unused bytes at the end of the union pointer
        ((self.pointer as usize) & (!0b11 as usize)) as *mut union_Elem
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Block`, with the appropriate payload
    pub fn Block(arg0: BlockConfig) -> Self {
            let size = core::mem::size_of::<union_Elem>();
            let align = core::mem::align_of::<union_Elem>() as u32;

            unsafe {
                let ptr = roc_std::roc_alloc_refcounted::<union_Elem>();

                *ptr = union_Elem {
                    Block: core::mem::ManuallyDrop::new(Elem_Block {
                    f0: arg0,
                })
                };

                Self {
                    pointer: Self::tag_discriminant(ptr, discriminant_Elem::Block),
                }
            }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Block` and convert it to `Block`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Block`.
            pub unsafe fn into_Block(mut self) -> BlockConfig {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Block);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Elem;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Block,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload.f0
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Block` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Block`.
            pub unsafe fn as_Block(&self) -> &BlockConfig {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Block);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Elem;

            unsafe { &(*ptr).Block }
        };

        
        &payload.f0
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Layout`, with the appropriate payload
    pub fn Layout(arg0: roc_std::RocList<Elem>, arg1: LayoutConfig) -> Self {
            let size = core::mem::size_of::<union_Elem>();
            let align = core::mem::align_of::<union_Elem>() as u32;

            unsafe {
                let ptr = roc_std::roc_alloc_refcounted::<union_Elem>();

                *ptr = union_Elem {
                    Layout: core::mem::ManuallyDrop::new(Elem_Layout {
                    f0: arg0,
                    f1: arg1,
                })
                };

                Self {
                    pointer: Self::tag_discriminant(ptr, discriminant_Elem::Layout),
                }
            }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Layout` and convert it to `Layout`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Layout`.
            pub unsafe fn into_Layout(mut self) -> (roc_std::RocList<Elem>, LayoutConfig) {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Layout);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Elem;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Layout,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Layout` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Layout`.
            pub unsafe fn as_Layout(&self) -> (&roc_std::RocList<Elem>, &LayoutConfig) {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Layout);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Elem;

            unsafe { &(*ptr).Layout }
        };

        (
            &payload.f0, 
            &payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `ListItems`, with the appropriate payload
    pub fn ListItems(arg0: ListConfig) -> Self {
            let size = core::mem::size_of::<union_Elem>();
            let align = core::mem::align_of::<union_Elem>() as u32;

            unsafe {
                let ptr = roc_std::roc_alloc_refcounted::<union_Elem>();

                *ptr = union_Elem {
                    ListItems: core::mem::ManuallyDrop::new(Elem_ListItems {
                    f0: arg0,
                })
                };

                Self {
                    pointer: Self::tag_discriminant(ptr, discriminant_Elem::ListItems),
                }
            }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `ListItems` and convert it to `ListItems`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `ListItems`.
            pub unsafe fn into_ListItems(mut self) -> ListConfig {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::ListItems);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Elem;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).ListItems,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload.f0
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `ListItems` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `ListItems`.
            pub unsafe fn as_ListItems(&self) -> &ListConfig {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::ListItems);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Elem;

            unsafe { &(*ptr).ListItems }
        };

        
        &payload.f0
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Paragraph`, with the appropriate payload
    pub fn Paragraph(arg0: ParagraphConfig) -> Self {
            let size = core::mem::size_of::<union_Elem>();
            let align = core::mem::align_of::<union_Elem>() as u32;

            unsafe {
                let ptr = roc_std::roc_alloc_refcounted::<union_Elem>();

                *ptr = union_Elem {
                    Paragraph: core::mem::ManuallyDrop::new(Elem_Paragraph {
                    f0: arg0,
                })
                };

                Self {
                    pointer: Self::tag_discriminant(ptr, discriminant_Elem::Paragraph),
                }
            }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Paragraph` and convert it to `Paragraph`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Paragraph`.
            pub unsafe fn into_Paragraph(mut self) -> ParagraphConfig {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Paragraph);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Elem;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Paragraph,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload.f0
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Paragraph` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Paragraph`.
            pub unsafe fn as_Paragraph(&self) -> &ParagraphConfig {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Paragraph);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Elem;

            unsafe { &(*ptr).Paragraph }
        };

        
        &payload.f0
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Elem {
        // The discriminant is stored in the unused bytes at the end of the recursive pointer
        unsafe { core::mem::transmute::<u8, discriminant_Elem>((self.pointer as u8) & 0b111) }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn tag_discriminant(pointer: *mut union_Elem, discriminant: discriminant_Elem) -> *mut union_Elem {
        // The discriminant is stored in the unused bytes at the end of the union pointer
        let untagged = (pointer as usize) & (!0b111 as usize);
        let tagged = untagged | (discriminant as usize);

        tagged as *mut union_Elem
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn union_pointer(&self) -> *mut union_Elem {
        // The discriminant is stored in the unused bytes at the end of the union pointer
        ((self.pointer as usize) & (!0b111 as usize)) as *mut union_Elem
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Block` and convert it to `Block`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Block`.
            pub unsafe fn into_Block(mut self) -> BlockConfig {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Block);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Elem;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Block,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload.f0
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Block` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Block`.
            pub unsafe fn as_Block(&self) -> &BlockConfig {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Block);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Elem;

            unsafe { &(*ptr).Block }
        };

        
        &payload.f0
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Layout` and convert it to `Layout`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Layout`.
            pub unsafe fn into_Layout(mut self) -> (roc_std::RocList<Elem>, LayoutConfig) {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Layout);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Elem;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Layout,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Layout` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Layout`.
            pub unsafe fn as_Layout(&self) -> (&roc_std::RocList<Elem>, &LayoutConfig) {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Layout);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Elem;

            unsafe { &(*ptr).Layout }
        };

        (
            &payload.f0, 
            &payload.f1
        )
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `ListItems` and convert it to `ListItems`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `ListItems`.
            pub unsafe fn into_ListItems(mut self) -> ListConfig {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::ListItems);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Elem;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).ListItems,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload.f0
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `ListItems` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `ListItems`.
            pub unsafe fn as_ListItems(&self) -> &ListConfig {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::ListItems);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Elem;

            unsafe { &(*ptr).ListItems }
        };

        
        &payload.f0
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Paragraph` and convert it to `Paragraph`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Paragraph`.
            pub unsafe fn into_Paragraph(mut self) -> ParagraphConfig {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Paragraph);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Elem;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Paragraph,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload.f0
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Paragraph` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Paragraph`.
            pub unsafe fn as_Paragraph(&self) -> &ParagraphConfig {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Paragraph);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Elem;

            unsafe { &(*ptr).Paragraph }
        };

        
        &payload.f0
    }
}

impl Drop for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // We only need to do any work if there's actually a heap-allocated payload.
        if let Some(storage) = self.storage() {
            let mut new_storage = storage.get();

            // Decrement the refcount
            let needs_dealloc = !new_storage.is_readonly() && new_storage.decrease();

            if needs_dealloc {
                // Drop the payload first.
                            match self.discriminant() {
                discriminant_Elem::Block => unsafe { core::mem::ManuallyDrop::drop(&mut (&mut *self.union_pointer()).Block) },
                discriminant_Elem::Layout => unsafe { core::mem::ManuallyDrop::drop(&mut (&mut *self.union_pointer()).Layout) },
                discriminant_Elem::ListItems => unsafe { core::mem::ManuallyDrop::drop(&mut (&mut *self.union_pointer()).ListItems) },
                discriminant_Elem::Paragraph => unsafe { core::mem::ManuallyDrop::drop(&mut (&mut *self.union_pointer()).Paragraph) },
            }


                // Dealloc the pointer
                let alignment = core::mem::align_of::<Self>().max(core::mem::align_of::<roc_std::Storage>());

                unsafe { crate::roc::roc_dealloc(storage.as_ptr().cast(), alignment as u32); }
            } else {
                // Write the storage back.
                storage.set(new_storage);
            }
        }
    }
}

impl Eq for Elem {}

impl PartialEq for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_Elem::Block => (&*self.union_pointer()).Block == (&*other.union_pointer()).Block,
                discriminant_Elem::Layout => (&*self.union_pointer()).Layout == (&*other.union_pointer()).Layout,
                discriminant_Elem::ListItems => (&*self.union_pointer()).ListItems == (&*other.union_pointer()).ListItems,
                discriminant_Elem::Paragraph => (&*self.union_pointer()).Paragraph == (&*other.union_pointer()).Paragraph,
            }
        }
    }
}

impl PartialOrd for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Elem::Block => (&*self.union_pointer()).Block.partial_cmp(&(&*other.union_pointer()).Block),
                discriminant_Elem::Layout => (&*self.union_pointer()).Layout.partial_cmp(&(&*other.union_pointer()).Layout),
                discriminant_Elem::ListItems => (&*self.union_pointer()).ListItems.partial_cmp(&(&*other.union_pointer()).ListItems),
                discriminant_Elem::Paragraph => (&*self.union_pointer()).Paragraph.partial_cmp(&(&*other.union_pointer()).Paragraph),
            }
        }
    }
}

impl Ord for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_Elem::Block => (&*self.union_pointer()).Block.cmp(&(&*other.union_pointer()).Block),
                discriminant_Elem::Layout => (&*self.union_pointer()).Layout.cmp(&(&*other.union_pointer()).Layout),
                discriminant_Elem::ListItems => (&*self.union_pointer()).ListItems.cmp(&(&*other.union_pointer()).ListItems),
                discriminant_Elem::Paragraph => (&*self.union_pointer()).Paragraph.cmp(&(&*other.union_pointer()).Paragraph),
            }
        }
    }
}

impl Clone for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        if let Some(storage) = self.storage() {
            let mut new_storage = storage.get();
            if !new_storage.is_readonly() {
                new_storage.increment_reference_count();
                storage.set(new_storage);
            }
        }

        Self {
            pointer: self.pointer
        }
    }
}

impl core::hash::Hash for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_Elem::Block => unsafe {
                    discriminant_Elem::Block.hash(state);
                    (&*self.union_pointer()).Block.hash(state);
                },
            discriminant_Elem::Layout => unsafe {
                    discriminant_Elem::Layout.hash(state);
                    (&*self.union_pointer()).Layout.hash(state);
                },
            discriminant_Elem::ListItems => unsafe {
                    discriminant_Elem::ListItems.hash(state);
                    (&*self.union_pointer()).ListItems.hash(state);
                },
            discriminant_Elem::Paragraph => unsafe {
                    discriminant_Elem::Paragraph.hash(state);
                    (&*self.union_pointer()).Paragraph.hash(state);
                },
        }
    }
}

impl core::fmt::Debug for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Elem::")?;

        unsafe {
            match self.discriminant() {
                discriminant_Elem::Block => f.debug_tuple("Block")
        .field(&(&*(&*self.union_pointer()).Block).f0)
        .finish(),
                discriminant_Elem::Layout => f.debug_tuple("Layout")
        .field(&(&*(&*self.union_pointer()).Layout).f0)
.field(&(&*(&*self.union_pointer()).Layout).f1)
        .finish(),
                discriminant_Elem::ListItems => f.debug_tuple("ListItems")
        .field(&(&*(&*self.union_pointer()).ListItems).f0)
        .finish(),
                discriminant_Elem::Paragraph => f.debug_tuple("Paragraph")
        .field(&(&*(&*self.union_pointer()).Paragraph).f0)
        .finish(),
            }
        }
    }
}

impl Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Event {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Event>(*bytes.as_ptr().add(16))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Event) {
        let discriminant_ptr: *mut discriminant_Event = (self as *mut Event).cast();

        unsafe {
            *(discriminant_ptr.add(16)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named FocusGained, which has no payload.
    pub const FocusGained: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Event>()];

        bytes[16] = discriminant_Event::FocusGained as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Event>()], Event>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the FocusGained tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_FocusGained(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the FocusGained tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_FocusGained(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named FocusLost, which has no payload.
    pub const FocusLost: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Event>()];

        bytes[16] = discriminant_Event::FocusLost as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Event>()], Event>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the FocusLost tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_FocusLost(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the FocusLost tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_FocusLost(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `KeyPressed`, with the appropriate payload
    pub fn KeyPressed(arg: KeyCode) -> Self {
            let mut answer = Self {
                KeyPressed: core::mem::ManuallyDrop::new(arg)
            };

            answer.set_discriminant(discriminant_Event::KeyPressed);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `KeyPressed` and convert it to `KeyPressed`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyPressed`.
            pub unsafe fn into_KeyPressed(mut self) -> KeyCode {
                debug_assert_eq!(self.discriminant(), discriminant_Event::KeyPressed);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.KeyPressed,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `KeyPressed` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyPressed`.
            pub unsafe fn as_KeyPressed(&self) -> &KeyCode {
                debug_assert_eq!(self.discriminant(), discriminant_Event::KeyPressed);
        let payload = &self.KeyPressed;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Paste`, with the appropriate payload
    pub fn Paste(arg: roc_std::RocStr) -> Self {
            let mut answer = Self {
                Paste: core::mem::ManuallyDrop::new(arg)
            };

            answer.set_discriminant(discriminant_Event::Paste);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Paste` and convert it to `Paste`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Paste`.
            pub unsafe fn into_Paste(mut self) -> roc_std::RocStr {
                debug_assert_eq!(self.discriminant(), discriminant_Event::Paste);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.Paste,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Paste` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Paste`.
            pub unsafe fn as_Paste(&self) -> &roc_std::RocStr {
                debug_assert_eq!(self.discriminant(), discriminant_Event::Paste);
        let payload = &self.Paste;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Resize`, with the appropriate payload
    pub fn Resize(arg0: Bounds) -> Self {
            let mut answer = Self {
                Resize: arg0
            };

            answer.set_discriminant(discriminant_Event::Resize);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Resize` and convert it to `Resize`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Resize`.
            pub unsafe fn into_Resize(self) -> Bounds {
                debug_assert_eq!(self.discriminant(), discriminant_Event::Resize);
        let payload = self.Resize;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Resize` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Resize`.
            pub unsafe fn as_Resize(&self) -> &Bounds {
                debug_assert_eq!(self.discriminant(), discriminant_Event::Resize);
        let payload = &self.Resize;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Tick, which has no payload.
    pub const Tick: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Event>()];

        bytes[16] = discriminant_Event::Tick as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Event>()], Event>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Tick tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Tick(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Tick tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Tick(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Event {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Event>(*bytes.as_ptr().add(32))
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Event) {
        let discriminant_ptr: *mut discriminant_Event = (self as *mut Event).cast();

        unsafe {
            *(discriminant_ptr.add(32)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named FocusGained, which has no payload.
    pub const FocusGained: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Event>()];

        bytes[32] = discriminant_Event::FocusGained as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Event>()], Event>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named FocusLost, which has no payload.
    pub const FocusLost: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Event>()];

        bytes[32] = discriminant_Event::FocusLost as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Event>()], Event>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Tick, which has no payload.
    pub const Tick: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Event>()];

        bytes[32] = discriminant_Event::Tick as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Event>()], Event>(bytes)
    };
}

impl Drop for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
                    match self.discriminant() {
                discriminant_Event::FocusGained => {}
                discriminant_Event::FocusLost => {}
                discriminant_Event::KeyPressed => unsafe { core::mem::ManuallyDrop::drop(&mut self.KeyPressed) },
                discriminant_Event::Paste => unsafe { core::mem::ManuallyDrop::drop(&mut self.Paste) },
                discriminant_Event::Resize => {}
                discriminant_Event::Tick => {}
            }

    }
}

impl Eq for Event {}

impl PartialEq for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_Event::FocusGained => true,
                discriminant_Event::FocusLost => true,
                discriminant_Event::KeyPressed => self.KeyPressed == other.KeyPressed,
                discriminant_Event::Paste => self.Paste == other.Paste,
                discriminant_Event::Resize => self.Resize == other.Resize,
                discriminant_Event::Tick => true,
            }
        }
    }
}

impl PartialOrd for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Event::FocusGained => Some(core::cmp::Ordering::Equal),
                discriminant_Event::FocusLost => Some(core::cmp::Ordering::Equal),
                discriminant_Event::KeyPressed => self.KeyPressed.partial_cmp(&other.KeyPressed),
                discriminant_Event::Paste => self.Paste.partial_cmp(&other.Paste),
                discriminant_Event::Resize => self.Resize.partial_cmp(&other.Resize),
                discriminant_Event::Tick => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_Event::FocusGained => core::cmp::Ordering::Equal,
                discriminant_Event::FocusLost => core::cmp::Ordering::Equal,
                discriminant_Event::KeyPressed => self.KeyPressed.cmp(&other.KeyPressed),
                discriminant_Event::Paste => self.Paste.cmp(&other.Paste),
                discriminant_Event::Resize => self.Resize.cmp(&other.Resize),
                discriminant_Event::Tick => core::cmp::Ordering::Equal,
            }
        }
    }
}

impl Clone for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_Event::FocusGained => core::mem::transmute::<
                    core::mem::MaybeUninit<Event>,
                    Event,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_Event::FocusLost => core::mem::transmute::<
                    core::mem::MaybeUninit<Event>,
                    Event,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_Event::KeyPressed => Self {
                    KeyPressed: self.KeyPressed.clone(),
                },
                discriminant_Event::Paste => Self {
                    Paste: self.Paste.clone(),
                },
                discriminant_Event::Resize => Self {
                    Resize: self.Resize.clone(),
                },
                discriminant_Event::Tick => core::mem::transmute::<
                    core::mem::MaybeUninit<Event>,
                    Event,
                >(core::mem::MaybeUninit::uninit()),
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_Event::FocusGained => discriminant_Event::FocusGained.hash(state),
            discriminant_Event::FocusLost => discriminant_Event::FocusLost.hash(state),
            discriminant_Event::KeyPressed => unsafe {
                    discriminant_Event::KeyPressed.hash(state);
                    self.KeyPressed.hash(state);
                },
            discriminant_Event::Paste => unsafe {
                    discriminant_Event::Paste.hash(state);
                    self.Paste.hash(state);
                },
            discriminant_Event::Resize => unsafe {
                    discriminant_Event::Resize.hash(state);
                    self.Resize.hash(state);
                },
            discriminant_Event::Tick => discriminant_Event::Tick.hash(state),
        }
    }
}

impl core::fmt::Debug for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Event::")?;

        unsafe {
            match self.discriminant() {
                discriminant_Event::FocusGained => f.write_str("FocusGained"),
                discriminant_Event::FocusLost => f.write_str("FocusLost"),
                discriminant_Event::KeyPressed => f.debug_tuple("KeyPressed")
        .field(&*self.KeyPressed)
        .finish(),
                discriminant_Event::Paste => f.debug_tuple("Paste")
        .field(&*self.Paste)
        .finish(),
                discriminant_Event::Resize => f.debug_tuple("Resize")
        .field(&self.Resize)
        .finish(),
                discriminant_Event::Tick => f.write_str("Tick"),
            }
        }
    }
}

impl Constraint {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Constraint {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Constraint>(*bytes.as_ptr().add(8))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Constraint) {
        let discriminant_ptr: *mut discriminant_Constraint = (self as *mut Constraint).cast();

        unsafe {
            *(discriminant_ptr.add(8)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Length`, with the appropriate payload
    pub fn Length(arg: u16) -> Self {
            let mut answer = Self {
                Length: arg
            };

            answer.set_discriminant(discriminant_Constraint::Length);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Length` and convert it to `Length`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Length`.
            pub unsafe fn into_Length(self) -> u16 {
                debug_assert_eq!(self.discriminant(), discriminant_Constraint::Length);
        let payload = self.Length;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Length` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Length`.
            pub unsafe fn as_Length(&self) -> &u16 {
                debug_assert_eq!(self.discriminant(), discriminant_Constraint::Length);
        let payload = &self.Length;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Max`, with the appropriate payload
    pub fn Max(arg: u16) -> Self {
            let mut answer = Self {
                Max: arg
            };

            answer.set_discriminant(discriminant_Constraint::Max);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Max` and convert it to `Max`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Max`.
            pub unsafe fn into_Max(self) -> u16 {
                debug_assert_eq!(self.discriminant(), discriminant_Constraint::Max);
        let payload = self.Max;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Max` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Max`.
            pub unsafe fn as_Max(&self) -> &u16 {
                debug_assert_eq!(self.discriminant(), discriminant_Constraint::Max);
        let payload = &self.Max;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Min`, with the appropriate payload
    pub fn Min(arg: u16) -> Self {
            let mut answer = Self {
                Min: arg
            };

            answer.set_discriminant(discriminant_Constraint::Min);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Min` and convert it to `Min`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Min`.
            pub unsafe fn into_Min(self) -> u16 {
                debug_assert_eq!(self.discriminant(), discriminant_Constraint::Min);
        let payload = self.Min;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Min` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Min`.
            pub unsafe fn as_Min(&self) -> &u16 {
                debug_assert_eq!(self.discriminant(), discriminant_Constraint::Min);
        let payload = &self.Min;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Percentage`, with the appropriate payload
    pub fn Percentage(arg: u16) -> Self {
            let mut answer = Self {
                Percentage: arg
            };

            answer.set_discriminant(discriminant_Constraint::Percentage);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Percentage` and convert it to `Percentage`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Percentage`.
            pub unsafe fn into_Percentage(self) -> u16 {
                debug_assert_eq!(self.discriminant(), discriminant_Constraint::Percentage);
        let payload = self.Percentage;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Percentage` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Percentage`.
            pub unsafe fn as_Percentage(&self) -> &u16 {
                debug_assert_eq!(self.discriminant(), discriminant_Constraint::Percentage);
        let payload = &self.Percentage;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Ratio`, with the appropriate payload
    pub fn Ratio(arg0: u32, arg1: u32) -> Self {
            let mut answer = Self {
                Ratio: Constraint_Ratio {
                    f0: arg0,
                    f1: arg1,
                }
            };

            answer.set_discriminant(discriminant_Constraint::Ratio);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Ratio` and convert it to `Ratio`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Ratio`.
            pub unsafe fn into_Ratio(self) -> (u32, u32) {
                debug_assert_eq!(self.discriminant(), discriminant_Constraint::Ratio);
        let payload = self.Ratio;

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Ratio` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Ratio`.
            pub unsafe fn as_Ratio(&self) -> (&u32, &u32) {
                debug_assert_eq!(self.discriminant(), discriminant_Constraint::Ratio);
        let payload = &self.Ratio;

        (
            &payload.f0, 
            &payload.f1
        )
    }
}

impl Eq for Constraint {}

impl PartialEq for Constraint {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_Constraint::Length => self.Length == other.Length,
                discriminant_Constraint::Max => self.Max == other.Max,
                discriminant_Constraint::Min => self.Min == other.Min,
                discriminant_Constraint::Percentage => self.Percentage == other.Percentage,
                discriminant_Constraint::Ratio => self.Ratio == other.Ratio,
            }
        }
    }
}

impl PartialOrd for Constraint {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Constraint::Length => self.Length.partial_cmp(&other.Length),
                discriminant_Constraint::Max => self.Max.partial_cmp(&other.Max),
                discriminant_Constraint::Min => self.Min.partial_cmp(&other.Min),
                discriminant_Constraint::Percentage => self.Percentage.partial_cmp(&other.Percentage),
                discriminant_Constraint::Ratio => self.Ratio.partial_cmp(&other.Ratio),
            }
        }
    }
}

impl Ord for Constraint {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_Constraint::Length => self.Length.cmp(&other.Length),
                discriminant_Constraint::Max => self.Max.cmp(&other.Max),
                discriminant_Constraint::Min => self.Min.cmp(&other.Min),
                discriminant_Constraint::Percentage => self.Percentage.cmp(&other.Percentage),
                discriminant_Constraint::Ratio => self.Ratio.cmp(&other.Ratio),
            }
        }
    }
}

impl Copy for Constraint {}

impl Clone for Constraint {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_Constraint::Length => Self {
                    Length: self.Length.clone(),
                },
                discriminant_Constraint::Max => Self {
                    Max: self.Max.clone(),
                },
                discriminant_Constraint::Min => Self {
                    Min: self.Min.clone(),
                },
                discriminant_Constraint::Percentage => Self {
                    Percentage: self.Percentage.clone(),
                },
                discriminant_Constraint::Ratio => Self {
                    Ratio: self.Ratio.clone(),
                },
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for Constraint {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_Constraint::Length => unsafe {
                    discriminant_Constraint::Length.hash(state);
                    self.Length.hash(state);
                },
            discriminant_Constraint::Max => unsafe {
                    discriminant_Constraint::Max.hash(state);
                    self.Max.hash(state);
                },
            discriminant_Constraint::Min => unsafe {
                    discriminant_Constraint::Min.hash(state);
                    self.Min.hash(state);
                },
            discriminant_Constraint::Percentage => unsafe {
                    discriminant_Constraint::Percentage.hash(state);
                    self.Percentage.hash(state);
                },
            discriminant_Constraint::Ratio => unsafe {
                    discriminant_Constraint::Ratio.hash(state);
                    self.Ratio.hash(state);
                },
        }
    }
}

impl core::fmt::Debug for Constraint {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Constraint::")?;

        unsafe {
            match self.discriminant() {
                discriminant_Constraint::Length => f.debug_tuple("Length")
        .field(&self.Length)
        .finish(),
                discriminant_Constraint::Max => f.debug_tuple("Max")
        .field(&self.Max)
        .finish(),
                discriminant_Constraint::Min => f.debug_tuple("Min")
        .field(&self.Min)
        .finish(),
                discriminant_Constraint::Percentage => f.debug_tuple("Percentage")
        .field(&self.Percentage)
        .finish(),
                discriminant_Constraint::Ratio => f.debug_tuple("Ratio")
        .field(&(&self.Ratio).f0)
.field(&(&self.Ratio).f1)
        .finish(),
            }
        }
    }
}

impl KeyCode {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_KeyCode {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_KeyCode>(*bytes.as_ptr().add(12))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_KeyCode) {
        let discriminant_ptr: *mut discriminant_KeyCode = (self as *mut KeyCode).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named BackTab, which has no payload.
    pub const BackTab: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::BackTab as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the BackTab tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_BackTab(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the BackTab tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_BackTab(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Backspace, which has no payload.
    pub const Backspace: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::Backspace as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Backspace tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Backspace(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Backspace tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Backspace(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named CapsLock, which has no payload.
    pub const CapsLock: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::CapsLock as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the CapsLock tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_CapsLock(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the CapsLock tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_CapsLock(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Delete, which has no payload.
    pub const Delete: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::Delete as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Delete tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Delete(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Delete tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Delete(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Down, which has no payload.
    pub const Down: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::Down as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Down tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Down(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Down tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Down(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named End, which has no payload.
    pub const End: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::End as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the End tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_End(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the End tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_End(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Enter, which has no payload.
    pub const Enter: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::Enter as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Enter tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Enter(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Enter tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Enter(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Esc, which has no payload.
    pub const Esc: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::Esc as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Esc tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Esc(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Esc tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Esc(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Function`, with the appropriate payload
    pub fn Function(arg: u8) -> Self {
            let mut answer = Self {
                Function: arg
            };

            answer.set_discriminant(discriminant_KeyCode::Function);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `Function` and convert it to `Function`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Function`.
            pub unsafe fn into_Function(self) -> u8 {
                debug_assert_eq!(self.discriminant(), discriminant_KeyCode::Function);
        let payload = self.Function;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `Function` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Function`.
            pub unsafe fn as_Function(&self) -> &u8 {
                debug_assert_eq!(self.discriminant(), discriminant_KeyCode::Function);
        let payload = &self.Function;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Home, which has no payload.
    pub const Home: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::Home as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Home tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Home(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Home tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Home(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Insert, which has no payload.
    pub const Insert: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::Insert as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Insert tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Insert(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Insert tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Insert(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named KeypadBegin, which has no payload.
    pub const KeypadBegin: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::KeypadBegin as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeypadBegin tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeypadBegin(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeypadBegin tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeypadBegin(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Left, which has no payload.
    pub const Left: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::Left as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Left tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Left(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Left tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Left(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Media`, with the appropriate payload
    pub fn Media(arg: MediaKeyCode) -> Self {
            let mut answer = Self {
                Media: arg
            };

            answer.set_discriminant(discriminant_KeyCode::Media);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `Media` and convert it to `Media`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Media`.
            pub unsafe fn into_Media(self) -> MediaKeyCode {
                debug_assert_eq!(self.discriminant(), discriminant_KeyCode::Media);
        let payload = self.Media;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `Media` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Media`.
            pub unsafe fn as_Media(&self) -> &MediaKeyCode {
                debug_assert_eq!(self.discriminant(), discriminant_KeyCode::Media);
        let payload = &self.Media;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Menu, which has no payload.
    pub const Menu: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::Menu as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Menu tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Menu(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Menu tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Menu(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Modifier`, with the appropriate payload
    pub fn Modifier(arg: ModifierKeyCode) -> Self {
            let mut answer = Self {
                Modifier: arg
            };

            answer.set_discriminant(discriminant_KeyCode::Modifier);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `Modifier` and convert it to `Modifier`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Modifier`.
            pub unsafe fn into_Modifier(self) -> ModifierKeyCode {
                debug_assert_eq!(self.discriminant(), discriminant_KeyCode::Modifier);
        let payload = self.Modifier;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `Modifier` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Modifier`.
            pub unsafe fn as_Modifier(&self) -> &ModifierKeyCode {
                debug_assert_eq!(self.discriminant(), discriminant_KeyCode::Modifier);
        let payload = &self.Modifier;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Null, which has no payload.
    pub const Null: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::Null as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Null tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Null(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Null tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Null(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named NumLock, which has no payload.
    pub const NumLock: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::NumLock as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the NumLock tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_NumLock(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the NumLock tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_NumLock(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named PageDown, which has no payload.
    pub const PageDown: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::PageDown as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the PageDown tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_PageDown(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the PageDown tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_PageDown(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named PageUp, which has no payload.
    pub const PageUp: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::PageUp as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the PageUp tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_PageUp(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the PageUp tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_PageUp(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Pause, which has no payload.
    pub const Pause: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::Pause as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Pause tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Pause(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Pause tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Pause(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named PrintScreen, which has no payload.
    pub const PrintScreen: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::PrintScreen as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the PrintScreen tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_PrintScreen(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the PrintScreen tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_PrintScreen(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Right, which has no payload.
    pub const Right: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::Right as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Right tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Right(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Right tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Right(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Scalar`, with the appropriate payload
    pub fn Scalar(arg: roc_std::RocStr) -> Self {
            let mut answer = Self {
                Scalar: core::mem::ManuallyDrop::new(arg)
            };

            answer.set_discriminant(discriminant_KeyCode::Scalar);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `Scalar` and convert it to `Scalar`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Scalar`.
            pub unsafe fn into_Scalar(mut self) -> roc_std::RocStr {
                debug_assert_eq!(self.discriminant(), discriminant_KeyCode::Scalar);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.Scalar,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `Scalar` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Scalar`.
            pub unsafe fn as_Scalar(&self) -> &roc_std::RocStr {
                debug_assert_eq!(self.discriminant(), discriminant_KeyCode::Scalar);
        let payload = &self.Scalar;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named ScrollLock, which has no payload.
    pub const ScrollLock: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::ScrollLock as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the ScrollLock tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_ScrollLock(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the ScrollLock tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_ScrollLock(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Tab, which has no payload.
    pub const Tab: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::Tab as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Tab tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Tab(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Tab tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Tab(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Up, which has no payload.
    pub const Up: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[12] = discriminant_KeyCode::Up as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Up tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Up(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Up tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Up(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_KeyCode {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_KeyCode>(*bytes.as_ptr().add(24))
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_KeyCode) {
        let discriminant_ptr: *mut discriminant_KeyCode = (self as *mut KeyCode).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named BackTab, which has no payload.
    pub const BackTab: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::BackTab as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Backspace, which has no payload.
    pub const Backspace: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::Backspace as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named CapsLock, which has no payload.
    pub const CapsLock: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::CapsLock as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Delete, which has no payload.
    pub const Delete: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::Delete as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Down, which has no payload.
    pub const Down: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::Down as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named End, which has no payload.
    pub const End: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::End as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Enter, which has no payload.
    pub const Enter: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::Enter as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Esc, which has no payload.
    pub const Esc: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::Esc as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Home, which has no payload.
    pub const Home: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::Home as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Insert, which has no payload.
    pub const Insert: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::Insert as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named KeypadBegin, which has no payload.
    pub const KeypadBegin: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::KeypadBegin as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Left, which has no payload.
    pub const Left: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::Left as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Menu, which has no payload.
    pub const Menu: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::Menu as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Null, which has no payload.
    pub const Null: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::Null as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named NumLock, which has no payload.
    pub const NumLock: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::NumLock as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named PageDown, which has no payload.
    pub const PageDown: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::PageDown as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named PageUp, which has no payload.
    pub const PageUp: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::PageUp as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Pause, which has no payload.
    pub const Pause: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::Pause as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named PrintScreen, which has no payload.
    pub const PrintScreen: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::PrintScreen as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Right, which has no payload.
    pub const Right: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::Right as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named ScrollLock, which has no payload.
    pub const ScrollLock: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::ScrollLock as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Tab, which has no payload.
    pub const Tab: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::Tab as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Up, which has no payload.
    pub const Up: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[24] = discriminant_KeyCode::Up as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };
}

impl Drop for KeyCode {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
                    match self.discriminant() {
                discriminant_KeyCode::BackTab => {}
                discriminant_KeyCode::Backspace => {}
                discriminant_KeyCode::CapsLock => {}
                discriminant_KeyCode::Delete => {}
                discriminant_KeyCode::Down => {}
                discriminant_KeyCode::End => {}
                discriminant_KeyCode::Enter => {}
                discriminant_KeyCode::Esc => {}
                discriminant_KeyCode::Function => {}
                discriminant_KeyCode::Home => {}
                discriminant_KeyCode::Insert => {}
                discriminant_KeyCode::KeypadBegin => {}
                discriminant_KeyCode::Left => {}
                discriminant_KeyCode::Media => {}
                discriminant_KeyCode::Menu => {}
                discriminant_KeyCode::Modifier => {}
                discriminant_KeyCode::Null => {}
                discriminant_KeyCode::NumLock => {}
                discriminant_KeyCode::PageDown => {}
                discriminant_KeyCode::PageUp => {}
                discriminant_KeyCode::Pause => {}
                discriminant_KeyCode::PrintScreen => {}
                discriminant_KeyCode::Right => {}
                discriminant_KeyCode::Scalar => unsafe { core::mem::ManuallyDrop::drop(&mut self.Scalar) },
                discriminant_KeyCode::ScrollLock => {}
                discriminant_KeyCode::Tab => {}
                discriminant_KeyCode::Up => {}
            }

    }
}

impl Eq for KeyCode {}

impl PartialEq for KeyCode {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_KeyCode::BackTab => true,
                discriminant_KeyCode::Backspace => true,
                discriminant_KeyCode::CapsLock => true,
                discriminant_KeyCode::Delete => true,
                discriminant_KeyCode::Down => true,
                discriminant_KeyCode::End => true,
                discriminant_KeyCode::Enter => true,
                discriminant_KeyCode::Esc => true,
                discriminant_KeyCode::Function => self.Function == other.Function,
                discriminant_KeyCode::Home => true,
                discriminant_KeyCode::Insert => true,
                discriminant_KeyCode::KeypadBegin => true,
                discriminant_KeyCode::Left => true,
                discriminant_KeyCode::Media => self.Media == other.Media,
                discriminant_KeyCode::Menu => true,
                discriminant_KeyCode::Modifier => self.Modifier == other.Modifier,
                discriminant_KeyCode::Null => true,
                discriminant_KeyCode::NumLock => true,
                discriminant_KeyCode::PageDown => true,
                discriminant_KeyCode::PageUp => true,
                discriminant_KeyCode::Pause => true,
                discriminant_KeyCode::PrintScreen => true,
                discriminant_KeyCode::Right => true,
                discriminant_KeyCode::Scalar => self.Scalar == other.Scalar,
                discriminant_KeyCode::ScrollLock => true,
                discriminant_KeyCode::Tab => true,
                discriminant_KeyCode::Up => true,
            }
        }
    }
}

impl PartialOrd for KeyCode {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_KeyCode::BackTab => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::Backspace => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::CapsLock => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::Delete => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::Down => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::End => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::Enter => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::Esc => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::Function => self.Function.partial_cmp(&other.Function),
                discriminant_KeyCode::Home => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::Insert => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::KeypadBegin => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::Left => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::Media => self.Media.partial_cmp(&other.Media),
                discriminant_KeyCode::Menu => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::Modifier => self.Modifier.partial_cmp(&other.Modifier),
                discriminant_KeyCode::Null => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::NumLock => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::PageDown => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::PageUp => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::Pause => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::PrintScreen => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::Right => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::Scalar => self.Scalar.partial_cmp(&other.Scalar),
                discriminant_KeyCode::ScrollLock => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::Tab => Some(core::cmp::Ordering::Equal),
                discriminant_KeyCode::Up => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for KeyCode {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_KeyCode::BackTab => core::cmp::Ordering::Equal,
                discriminant_KeyCode::Backspace => core::cmp::Ordering::Equal,
                discriminant_KeyCode::CapsLock => core::cmp::Ordering::Equal,
                discriminant_KeyCode::Delete => core::cmp::Ordering::Equal,
                discriminant_KeyCode::Down => core::cmp::Ordering::Equal,
                discriminant_KeyCode::End => core::cmp::Ordering::Equal,
                discriminant_KeyCode::Enter => core::cmp::Ordering::Equal,
                discriminant_KeyCode::Esc => core::cmp::Ordering::Equal,
                discriminant_KeyCode::Function => self.Function.cmp(&other.Function),
                discriminant_KeyCode::Home => core::cmp::Ordering::Equal,
                discriminant_KeyCode::Insert => core::cmp::Ordering::Equal,
                discriminant_KeyCode::KeypadBegin => core::cmp::Ordering::Equal,
                discriminant_KeyCode::Left => core::cmp::Ordering::Equal,
                discriminant_KeyCode::Media => self.Media.cmp(&other.Media),
                discriminant_KeyCode::Menu => core::cmp::Ordering::Equal,
                discriminant_KeyCode::Modifier => self.Modifier.cmp(&other.Modifier),
                discriminant_KeyCode::Null => core::cmp::Ordering::Equal,
                discriminant_KeyCode::NumLock => core::cmp::Ordering::Equal,
                discriminant_KeyCode::PageDown => core::cmp::Ordering::Equal,
                discriminant_KeyCode::PageUp => core::cmp::Ordering::Equal,
                discriminant_KeyCode::Pause => core::cmp::Ordering::Equal,
                discriminant_KeyCode::PrintScreen => core::cmp::Ordering::Equal,
                discriminant_KeyCode::Right => core::cmp::Ordering::Equal,
                discriminant_KeyCode::Scalar => self.Scalar.cmp(&other.Scalar),
                discriminant_KeyCode::ScrollLock => core::cmp::Ordering::Equal,
                discriminant_KeyCode::Tab => core::cmp::Ordering::Equal,
                discriminant_KeyCode::Up => core::cmp::Ordering::Equal,
            }
        }
    }
}

impl Clone for KeyCode {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_KeyCode::BackTab => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::Backspace => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::CapsLock => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::Delete => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::Down => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::End => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::Enter => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::Esc => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::Function => Self {
                    Function: self.Function.clone(),
                },
                discriminant_KeyCode::Home => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::Insert => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::KeypadBegin => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::Left => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::Media => Self {
                    Media: self.Media.clone(),
                },
                discriminant_KeyCode::Menu => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::Modifier => Self {
                    Modifier: self.Modifier.clone(),
                },
                discriminant_KeyCode::Null => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::NumLock => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::PageDown => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::PageUp => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::Pause => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::PrintScreen => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::Right => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::Scalar => Self {
                    Scalar: self.Scalar.clone(),
                },
                discriminant_KeyCode::ScrollLock => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::Tab => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_KeyCode::Up => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for KeyCode {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_KeyCode::BackTab => discriminant_KeyCode::BackTab.hash(state),
            discriminant_KeyCode::Backspace => discriminant_KeyCode::Backspace.hash(state),
            discriminant_KeyCode::CapsLock => discriminant_KeyCode::CapsLock.hash(state),
            discriminant_KeyCode::Delete => discriminant_KeyCode::Delete.hash(state),
            discriminant_KeyCode::Down => discriminant_KeyCode::Down.hash(state),
            discriminant_KeyCode::End => discriminant_KeyCode::End.hash(state),
            discriminant_KeyCode::Enter => discriminant_KeyCode::Enter.hash(state),
            discriminant_KeyCode::Esc => discriminant_KeyCode::Esc.hash(state),
            discriminant_KeyCode::Function => unsafe {
                    discriminant_KeyCode::Function.hash(state);
                    self.Function.hash(state);
                },
            discriminant_KeyCode::Home => discriminant_KeyCode::Home.hash(state),
            discriminant_KeyCode::Insert => discriminant_KeyCode::Insert.hash(state),
            discriminant_KeyCode::KeypadBegin => discriminant_KeyCode::KeypadBegin.hash(state),
            discriminant_KeyCode::Left => discriminant_KeyCode::Left.hash(state),
            discriminant_KeyCode::Media => unsafe {
                    discriminant_KeyCode::Media.hash(state);
                    self.Media.hash(state);
                },
            discriminant_KeyCode::Menu => discriminant_KeyCode::Menu.hash(state),
            discriminant_KeyCode::Modifier => unsafe {
                    discriminant_KeyCode::Modifier.hash(state);
                    self.Modifier.hash(state);
                },
            discriminant_KeyCode::Null => discriminant_KeyCode::Null.hash(state),
            discriminant_KeyCode::NumLock => discriminant_KeyCode::NumLock.hash(state),
            discriminant_KeyCode::PageDown => discriminant_KeyCode::PageDown.hash(state),
            discriminant_KeyCode::PageUp => discriminant_KeyCode::PageUp.hash(state),
            discriminant_KeyCode::Pause => discriminant_KeyCode::Pause.hash(state),
            discriminant_KeyCode::PrintScreen => discriminant_KeyCode::PrintScreen.hash(state),
            discriminant_KeyCode::Right => discriminant_KeyCode::Right.hash(state),
            discriminant_KeyCode::Scalar => unsafe {
                    discriminant_KeyCode::Scalar.hash(state);
                    self.Scalar.hash(state);
                },
            discriminant_KeyCode::ScrollLock => discriminant_KeyCode::ScrollLock.hash(state),
            discriminant_KeyCode::Tab => discriminant_KeyCode::Tab.hash(state),
            discriminant_KeyCode::Up => discriminant_KeyCode::Up.hash(state),
        }
    }
}

impl core::fmt::Debug for KeyCode {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("KeyCode::")?;

        unsafe {
            match self.discriminant() {
                discriminant_KeyCode::BackTab => f.write_str("BackTab"),
                discriminant_KeyCode::Backspace => f.write_str("Backspace"),
                discriminant_KeyCode::CapsLock => f.write_str("CapsLock"),
                discriminant_KeyCode::Delete => f.write_str("Delete"),
                discriminant_KeyCode::Down => f.write_str("Down"),
                discriminant_KeyCode::End => f.write_str("End"),
                discriminant_KeyCode::Enter => f.write_str("Enter"),
                discriminant_KeyCode::Esc => f.write_str("Esc"),
                discriminant_KeyCode::Function => f.debug_tuple("Function")
        .field(&self.Function)
        .finish(),
                discriminant_KeyCode::Home => f.write_str("Home"),
                discriminant_KeyCode::Insert => f.write_str("Insert"),
                discriminant_KeyCode::KeypadBegin => f.write_str("KeypadBegin"),
                discriminant_KeyCode::Left => f.write_str("Left"),
                discriminant_KeyCode::Media => f.debug_tuple("Media")
        .field(&self.Media)
        .finish(),
                discriminant_KeyCode::Menu => f.write_str("Menu"),
                discriminant_KeyCode::Modifier => f.debug_tuple("Modifier")
        .field(&self.Modifier)
        .finish(),
                discriminant_KeyCode::Null => f.write_str("Null"),
                discriminant_KeyCode::NumLock => f.write_str("NumLock"),
                discriminant_KeyCode::PageDown => f.write_str("PageDown"),
                discriminant_KeyCode::PageUp => f.write_str("PageUp"),
                discriminant_KeyCode::Pause => f.write_str("Pause"),
                discriminant_KeyCode::PrintScreen => f.write_str("PrintScreen"),
                discriminant_KeyCode::Right => f.write_str("Right"),
                discriminant_KeyCode::Scalar => f.debug_tuple("Scalar")
        .field(&*self.Scalar)
        .finish(),
                discriminant_KeyCode::ScrollLock => f.write_str("ScrollLock"),
                discriminant_KeyCode::Tab => f.write_str("Tab"),
                discriminant_KeyCode::Up => f.write_str("Up"),
            }
        }
    }
}

impl Cursor {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Cursor {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Cursor>(*bytes.as_ptr().add(4))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Cursor) {
        let discriminant_ptr: *mut discriminant_Cursor = (self as *mut Cursor).cast();

        unsafe {
            *(discriminant_ptr.add(4)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `At`, with the appropriate payload
    pub fn At(arg0: CursorPosition) -> Self {
            let mut answer = Self {
                At: arg0
            };

            answer.set_discriminant(discriminant_Cursor::At);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Cursor` has a `.discriminant()` of `At` and convert it to `At`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `At`.
            pub unsafe fn into_At(self) -> CursorPosition {
                debug_assert_eq!(self.discriminant(), discriminant_Cursor::At);
        let payload = self.At;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Cursor` has a `.discriminant()` of `At` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `At`.
            pub unsafe fn as_At(&self) -> &CursorPosition {
                debug_assert_eq!(self.discriminant(), discriminant_Cursor::At);
        let payload = &self.At;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Hidden, which has no payload.
    pub const Hidden: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Cursor>()];

        bytes[4] = discriminant_Cursor::Hidden as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Cursor>()], Cursor>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Hidden tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Hidden(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Hidden tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Hidden(&self) {
        ()
    }
}

impl Eq for Cursor {}

impl PartialEq for Cursor {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_Cursor::At => self.At == other.At,
                discriminant_Cursor::Hidden => true,
            }
        }
    }
}

impl PartialOrd for Cursor {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Cursor::At => self.At.partial_cmp(&other.At),
                discriminant_Cursor::Hidden => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for Cursor {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_Cursor::At => self.At.cmp(&other.At),
                discriminant_Cursor::Hidden => core::cmp::Ordering::Equal,
            }
        }
    }
}

impl Copy for Cursor {}

impl Clone for Cursor {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_Cursor::At => Self {
                    At: self.At.clone(),
                },
                discriminant_Cursor::Hidden => core::mem::transmute::<
                    core::mem::MaybeUninit<Cursor>,
                    Cursor,
                >(core::mem::MaybeUninit::uninit()),
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for Cursor {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_Cursor::At => unsafe {
                    discriminant_Cursor::At.hash(state);
                    self.At.hash(state);
                },
            discriminant_Cursor::Hidden => discriminant_Cursor::Hidden.hash(state),
        }
    }
}

impl core::fmt::Debug for Cursor {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Cursor::")?;

        unsafe {
            match self.discriminant() {
                discriminant_Cursor::At => f.debug_tuple("At")
        .field(&self.At)
        .finish(),
                discriminant_Cursor::Hidden => f.write_str("Hidden"),
            }
        }
    }
}

impl ListSelection {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ListSelection {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ListSelection>(*bytes.as_ptr().add(4))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ListSelection) {
        let discriminant_ptr: *mut discriminant_ListSelection = (self as *mut ListSelection).cast();

        unsafe {
            *(discriminant_ptr.add(4)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named None, which has no payload.
    pub const None: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ListSelection>()];

        bytes[4] = discriminant_ListSelection::None as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ListSelection>()], ListSelection>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_None(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_None(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Construct a tag named `Selected`, with the appropriate payload
    pub fn Selected(arg: u32) -> Self {
            let mut answer = Self {
                Selected: arg
            };

            answer.set_discriminant(discriminant_ListSelection::Selected);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `ListSelection` has a `.discriminant()` of `Selected` and convert it to `Selected`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Selected`.
            pub unsafe fn into_Selected(self) -> u32 {
                debug_assert_eq!(self.discriminant(), discriminant_ListSelection::Selected);
        let payload = self.Selected;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `ListSelection` has a `.discriminant()` of `Selected` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Selected`.
            pub unsafe fn as_Selected(&self) -> &u32 {
                debug_assert_eq!(self.discriminant(), discriminant_ListSelection::Selected);
        let payload = &self.Selected;

        &payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ListSelection {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ListSelection>(*bytes.as_ptr().add(8))
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ListSelection) {
        let discriminant_ptr: *mut discriminant_ListSelection = (self as *mut ListSelection).cast();

        unsafe {
            *(discriminant_ptr.add(8)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named None, which has no payload.
    pub const None: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ListSelection>()];

        bytes[8] = discriminant_ListSelection::None as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ListSelection>()], ListSelection>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Selected`, with the appropriate payload
    pub fn Selected(arg: u64) -> Self {
            let mut answer = Self {
                Selected: arg
            };

            answer.set_discriminant(discriminant_ListSelection::Selected);

            answer
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `ListSelection` has a `.discriminant()` of `Selected` and convert it to `Selected`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Selected`.
            pub unsafe fn into_Selected(self) -> u64 {
                debug_assert_eq!(self.discriminant(), discriminant_ListSelection::Selected);
        let payload = self.Selected;

        payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `ListSelection` has a `.discriminant()` of `Selected` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Selected`.
            pub unsafe fn as_Selected(&self) -> &u64 {
                debug_assert_eq!(self.discriminant(), discriminant_ListSelection::Selected);
        let payload = &self.Selected;

        &payload
    }
}

impl Eq for ListSelection {}

impl PartialEq for ListSelection {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_ListSelection::None => true,
                discriminant_ListSelection::Selected => self.Selected == other.Selected,
            }
        }
    }
}

impl PartialOrd for ListSelection {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_ListSelection::None => Some(core::cmp::Ordering::Equal),
                discriminant_ListSelection::Selected => self.Selected.partial_cmp(&other.Selected),
            }
        }
    }
}

impl Ord for ListSelection {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_ListSelection::None => core::cmp::Ordering::Equal,
                discriminant_ListSelection::Selected => self.Selected.cmp(&other.Selected),
            }
        }
    }
}

impl Copy for ListSelection {}

impl Clone for ListSelection {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_ListSelection::None => core::mem::transmute::<
                    core::mem::MaybeUninit<ListSelection>,
                    ListSelection,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_ListSelection::Selected => Self {
                    Selected: self.Selected.clone(),
                },
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for ListSelection {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_ListSelection::None => discriminant_ListSelection::None.hash(state),
            discriminant_ListSelection::Selected => unsafe {
                    discriminant_ListSelection::Selected.hash(state);
                    self.Selected.hash(state);
                },
        }
    }
}

impl core::fmt::Debug for ListSelection {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("ListSelection::")?;

        unsafe {
            match self.discriminant() {
                discriminant_ListSelection::None => f.write_str("None"),
                discriminant_ListSelection::Selected => f.debug_tuple("Selected")
        .field(&self.Selected)
        .finish(),
            }
        }
    }
}

impl PopupConfig {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_PopupConfig {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_PopupConfig>(*bytes.as_ptr().add(4))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_PopupConfig) {
        let discriminant_ptr: *mut discriminant_PopupConfig = (self as *mut PopupConfig).cast();

        unsafe {
            *(discriminant_ptr.add(4)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Centered`, with the appropriate payload
    pub fn Centered(arg0: ModalPosition) -> Self {
            let mut answer = Self {
                Centered: arg0
            };

            answer.set_discriminant(discriminant_PopupConfig::Centered);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `PopupConfig` has a `.discriminant()` of `Centered` and convert it to `Centered`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Centered`.
            pub unsafe fn into_Centered(self) -> ModalPosition {
                debug_assert_eq!(self.discriminant(), discriminant_PopupConfig::Centered);
        let payload = self.Centered;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `PopupConfig` has a `.discriminant()` of `Centered` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Centered`.
            pub unsafe fn as_Centered(&self) -> &ModalPosition {
                debug_assert_eq!(self.discriminant(), discriminant_PopupConfig::Centered);
        let payload = &self.Centered;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named None, which has no payload.
    pub const None: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<PopupConfig>()];

        bytes[4] = discriminant_PopupConfig::None as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<PopupConfig>()], PopupConfig>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_None(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_None(&self) {
        ()
    }
}

impl Eq for PopupConfig {}

impl PartialEq for PopupConfig {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_PopupConfig::Centered => self.Centered == other.Centered,
                discriminant_PopupConfig::None => true,
            }
        }
    }
}

impl PartialOrd for PopupConfig {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_PopupConfig::Centered => self.Centered.partial_cmp(&other.Centered),
                discriminant_PopupConfig::None => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for PopupConfig {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_PopupConfig::Centered => self.Centered.cmp(&other.Centered),
                discriminant_PopupConfig::None => core::cmp::Ordering::Equal,
            }
        }
    }
}

impl Copy for PopupConfig {}

impl Clone for PopupConfig {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_PopupConfig::Centered => Self {
                    Centered: self.Centered.clone(),
                },
                discriminant_PopupConfig::None => core::mem::transmute::<
                    core::mem::MaybeUninit<PopupConfig>,
                    PopupConfig,
                >(core::mem::MaybeUninit::uninit()),
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for PopupConfig {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_PopupConfig::Centered => unsafe {
                    discriminant_PopupConfig::Centered.hash(state);
                    self.Centered.hash(state);
                },
            discriminant_PopupConfig::None => discriminant_PopupConfig::None.hash(state),
        }
    }
}

impl core::fmt::Debug for PopupConfig {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("PopupConfig::")?;

        unsafe {
            match self.discriminant() {
                discriminant_PopupConfig::Centered => f.debug_tuple("Centered")
        .field(&self.Centered)
        .finish(),
                discriminant_PopupConfig::None => f.write_str("None"),
            }
        }
    }
}

impl Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Color {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Color>(*bytes.as_ptr().add(3))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Color) {
        let discriminant_ptr: *mut discriminant_Color = (self as *mut Color).cast();

        unsafe {
            *(discriminant_ptr.add(3)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Black, which has no payload.
    pub const Black: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[3] = discriminant_Color::Black as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Black tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Black(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Black tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Black(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Blue, which has no payload.
    pub const Blue: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[3] = discriminant_Color::Blue as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Blue tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Blue(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Blue tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Blue(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Default, which has no payload.
    pub const Default: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[3] = discriminant_Color::Default as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Default tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Default(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Default tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Default(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Green, which has no payload.
    pub const Green: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[3] = discriminant_Color::Green as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Green tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Green(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Green tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Green(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Red, which has no payload.
    pub const Red: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[3] = discriminant_Color::Red as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Red tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Red(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Red tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Red(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Rgb`, with the appropriate payload
    pub fn Rgb(arg0: u8, arg1: u8, arg2: u8) -> Self {
            let mut answer = Self {
                Rgb: Color_Rgb {
                    f0: arg0,
                    f1: arg1,
                    f2: arg2,
                }
            };

            answer.set_discriminant(discriminant_Color::Rgb);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Color` has a `.discriminant()` of `Rgb` and convert it to `Rgb`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Rgb`.
            pub unsafe fn into_Rgb(self) -> (u8, u8, u8) {
                debug_assert_eq!(self.discriminant(), discriminant_Color::Rgb);
        let payload = self.Rgb;

        (
            payload.f0, 
            payload.f1, 
            payload.f2
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Color` has a `.discriminant()` of `Rgb` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Rgb`.
            pub unsafe fn as_Rgb(&self) -> (&u8, &u8, &u8) {
                debug_assert_eq!(self.discriminant(), discriminant_Color::Rgb);
        let payload = &self.Rgb;

        (
            &payload.f0, 
            &payload.f1, 
            &payload.f2
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named White, which has no payload.
    pub const White: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[3] = discriminant_Color::White as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the White tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_White(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the White tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_White(&self) {
        ()
    }
}

impl Eq for Color {}

impl PartialEq for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_Color::Black => true,
                discriminant_Color::Blue => true,
                discriminant_Color::Default => true,
                discriminant_Color::Green => true,
                discriminant_Color::Red => true,
                discriminant_Color::Rgb => self.Rgb == other.Rgb,
                discriminant_Color::White => true,
            }
        }
    }
}

impl PartialOrd for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Color::Black => Some(core::cmp::Ordering::Equal),
                discriminant_Color::Blue => Some(core::cmp::Ordering::Equal),
                discriminant_Color::Default => Some(core::cmp::Ordering::Equal),
                discriminant_Color::Green => Some(core::cmp::Ordering::Equal),
                discriminant_Color::Red => Some(core::cmp::Ordering::Equal),
                discriminant_Color::Rgb => self.Rgb.partial_cmp(&other.Rgb),
                discriminant_Color::White => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_Color::Black => core::cmp::Ordering::Equal,
                discriminant_Color::Blue => core::cmp::Ordering::Equal,
                discriminant_Color::Default => core::cmp::Ordering::Equal,
                discriminant_Color::Green => core::cmp::Ordering::Equal,
                discriminant_Color::Red => core::cmp::Ordering::Equal,
                discriminant_Color::Rgb => self.Rgb.cmp(&other.Rgb),
                discriminant_Color::White => core::cmp::Ordering::Equal,
            }
        }
    }
}

impl Copy for Color {}

impl Clone for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_Color::Black => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_Color::Blue => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_Color::Default => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_Color::Green => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_Color::Red => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_Color::Rgb => Self {
                    Rgb: self.Rgb.clone(),
                },
                discriminant_Color::White => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_Color::Black => discriminant_Color::Black.hash(state),
            discriminant_Color::Blue => discriminant_Color::Blue.hash(state),
            discriminant_Color::Default => discriminant_Color::Default.hash(state),
            discriminant_Color::Green => discriminant_Color::Green.hash(state),
            discriminant_Color::Red => discriminant_Color::Red.hash(state),
            discriminant_Color::Rgb => unsafe {
                    discriminant_Color::Rgb.hash(state);
                    self.Rgb.hash(state);
                },
            discriminant_Color::White => discriminant_Color::White.hash(state),
        }
    }
}

impl core::fmt::Debug for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Color::")?;

        unsafe {
            match self.discriminant() {
                discriminant_Color::Black => f.write_str("Black"),
                discriminant_Color::Blue => f.write_str("Blue"),
                discriminant_Color::Default => f.write_str("Default"),
                discriminant_Color::Green => f.write_str("Green"),
                discriminant_Color::Red => f.write_str("Red"),
                discriminant_Color::Rgb => f.debug_tuple("Rgb")
        .field(&(&self.Rgb).f0)
.field(&(&self.Rgb).f1)
.field(&(&self.Rgb).f2)
        .finish(),
                discriminant_Color::White => f.write_str("White"),
            }
        }
    }
}
